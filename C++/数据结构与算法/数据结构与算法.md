## 1. 简介

### 1.1 数据结构简介

​		**数据结构**是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

### 1.2 数据结构分类

传统上，我们可以把数据结构分为逻辑结构和物理结构两大类。

**逻辑结构分类:**
		逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类有下面几种。

- **集合结构:**集合结构中数据元素除了**属于同一个集合**外，他们之间没有任何其他的关系。

- **线性结构:**线性结构中的数据元素之间存在**一对一**的关系
- **树形结构:**树形结构中的数据元素之间存在**—对多**的层次关系

- **图形结构:**图形结构的数据元素是**多对多**的关系

**物理结构分类:**
		逻辑结构在计算机中真正的表示方式(又称为映像)称为物理结构，也可以叫做存储结构。常见的物理结构有**顺序存储结构**、**链式存储结构**。

**顺序存储结构:**
		把数据元素放到地址**连续的存储单元**里面，其数据间的**逻辑关系和物理关系是一致**的，比如我们常用的数组就是顺序存储结构。

​		顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中此时就需要链式存储结构。

**链式存储结构:**
		是把数据元素存放在**任意的存储单元**里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并**不能反映元素间的逻辑关系**，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

### 1.3 算法简介

​		**算法**是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着**用系统的方法解决问题的策略机制**。也就是说，能够对—定规范的输入，在有限时间内获得所要求的输出。

​		在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算法追求以下两个目标∶

- 花最少的时间完成需求;
- 占用最少的内存空间完成需求;

## 2. 算法分析

### 2.1 时间复杂度分析

**分析方法:**

**事后分析估算方法:**
		比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷∶必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。

**事前分析估算方法:**
		在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机上运行所消耗的时间取决于下列因素:

1. 算法采用的策略和方案;
2. 编译产生的代码质量;
3. 问题的输入规模(所谓的问题输入规模就是输入量的多少);
4. 机器执行指令的速度;

​		由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

​		我们研究算法复杂度，侧重的是**当输入规模不断增大时，算法的增长量的一个抽象(规律)**，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。

​		我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把**核心操作的次数和输入规模关联起来**。

**比较算法随输入规模的增长量时，可以有以下规则:**

1. 算法函数中的常数可以忽略;
2. 算法函数中最高次幂的常数因子可以忽略;
3. 算法函数中最高次幂越小，算法效率越高。

### 2.2 大O记法

​		在进行算法分析时，语句总的执行次数T(n)关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。
​		算法的时间复杂度，就是算法的时间量度，记作:`T(n)=O(f(n))`。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。

​		在这里，我们需要明确一个事情:**执行次数 = 执行时间**
用大写O()来体现算法时间复杂度的记法，我们称之为**大O记法**。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

**推导大O阶的表示法有以下几个规则可以使用:**

1. 用常数1**取代运行时间中的所有加法常数**;
2. 在修改后的运行次数中，只**保留高阶项**;
3. 如果最高阶项存在，且常数因子不为1，则**去除与这个项相乘的常数**;

### 2.3 常见的大O阶

#### 2.3.1 线性阶

一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    sum += i;
}
cout<<"sum="<<sum<<endl;
```

时间复杂度为O(n)

#### 2.3.2 平方阶

一般嵌套循环属于这种时间复杂度

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    for(int j = 1;j <= n; j++)
    {
        sum += i;
    }
}
cout<<"sum="<<sum<<endl;
```

时间复杂度O(n^2)

#### 2.3.3 立方阶

一般三层嵌套循环属于这种时间复杂度

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    for(int j = 1;j <= n; j++)
    {
       for(int j = i;j <= n; j++)
       {
           sum += i;
       }
    }
}
cout<<"sum="<<sum<<endl;
```

时间复杂度O(n^3)

#### 2.3.4 对数阶

```c++
int i = 1,n = 100;
while(i<n)
{
    i = i*2;
}
```

由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n

时间复杂度O(log n)

#### 2.3.5 常数阶

```c++
int n = 100;
int i = n+2;
cout<<i<<endl;
```

上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以时间复杂度为O(1)

#### 2.3.6 总结

**常见的大O阶:**

| 描述         | 增长的数量级 | 说明     | 举例           |
| ------------ | ------------ | -------- | -------------- |
| 常数级别     | 1            | 普通语句 | 将两个教相加   |
| 对数级别     | logN         | 二分策略 | 二分查找       |
| 线性级别     | N            | 循环     | 找出最大元素   |
| 线型对数级别 | NlogN        | 分治思想 | 归并排序       |
| 平方级别     | N^2          | 双层循环 | 检查所有元素对 |
| 立方级别     | N^3          | 三层循环 | 检查所有三元组 |
| 指数级别     | 2^N          | 穷举查找 | 检查所有子集   |

**复杂度高低**

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3)

### 2.4 最坏情况

```c++
int search(int num)
{
    int arr[10]={11,10,8,9,7,22,23,0};
	for(int i = 0;i<10;i++)
	{
    	if(num == arr[i])
    	{
        	return i;
		}
	}
    return -1;
}
```

**最好情况:**
查找的第一个数字就是期望的数字,那么算法的时间复杂度为O(1)

**最坏情况:**
查找的最后一个数字,才是期望的数字，那么算法的时间复杂度为O(n)

**平均情况:**
任何数字查找的平均成本是O(n/2)

## 3. 简单排序

### 3.1 冒泡排序

冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法。

**排序原理:**

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。

**代码实现:**

```c++
vector<int> bubble_sort(vector<int> a, int n)
{
    /**
     * @brief 冒泡排序
     * 
     */
    for (int i = n - 1; i > 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            if (a[j] > a[j + 1])
            {
                swap(a[j], a[j + 1]);
            }
        }
    }
    return a;
}
```

### 3.2 选择排序

选择排序(select sort)是—种更加简单直观的排序方法。

**排序原理:**

1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值

**代码实现:**

```c++
vector<int> select_sort(vector<int> a, int n)
{
    /**
     * @brief 选择排序
     * 
     */
    for (int i = 0; i < n-2; i++)
    {
        int min = i;
        for (int j = i + 1; j < n; j++)
        {
            if (a[j] < a[min])
                min = j;
        }
        swap(a[i], a[min]);
    } 
    return a;
}
```

### 3.3 插入排序

插入排序（insert sort )是一种简单直观且稳定的排序算法。

**排序原理:**

1. 把所有的元素分为两组，已经排序的和未排序的;
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入;
3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位;

**代码实现:**

```c++
vector<int> inert_sort(vector<int> a, int n)
{
    /**
     * @brief 插入排序
     * 
     */
    for (int i = 1; i < n; i++)
    {
        for (int j = i; j > 0; j--)
        {
            if (a[j] < a[j - 1])
                swap(a[j], a[j - 1]);
            else
                break;
        }
    }
    return a;
}
```

## 4. 高级排序

### 4.1 希尔排序

希尔排序(shell sort)是插入排序的一种，又称"缩小增量排序”，是插入排序算法的一种更高效的改进版本。

**排序原理:**

1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组;
2. 对分好组的每一组数据完成插入排序;
3. 减小增长量，最小减为1，重复第二步操作。

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/b85c69dd08a98e0591a3b16b385d4f0c.png)

**增长量h的确定:** 

```c++
int h=1
while(h<数组的长度/2){
	h=2h+1 ;
}
//不结束后我们就可以确定h的最大值;
h的减小规则为:
	h=h/2
```

**代码实现:**

```c++
vector<int> shell_sort(vector<int> a, int n)
{
    /**
    * @brief 希尔排序
    * 
    */
    int h = 1;
    while (h < n / 2)
        h = 2 * h + 1;
    while (h >= 1)
    {
        for (int i = h; i < n; i++)
        {
            for (int j = i; j >= h; j -= h)
            {
                if (a[j - h] > a[j])
                    swap(a[j - h], a[j]);
                else
                    break;
            }
        }
        h = h / 2;
    }
    return a;
}
```

### 4.2 并归排序

#### 4.2.1 递归

**定义:**
		定义方法时，在方法内部调用方法本身，称之为递归.

```c++
void fun()
{
    cout << "hello world" << endl;
    fun();
}
```

**作用:**
		它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。

**注意事项:**
		在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每
一次递归调用都会在栈内存开辟新的空间，重新执行方法，**如果递归的层级太深，很容易造成栈内存溢出**。

```c++
//求n的阶乘
int fac(int n)
{
    if (n == 1)
        return 1;
    return n * fac(n - 1);
}
```

#### 4.2.2 并归排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用**分治法**的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

**排序原理:**

1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。

2. 将相邻的两个子组进行合并成一个有序的大组;
3. 不断的重复步骤2，直到最终只有一个组为止。

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/815896ccf2d65e5fb3eb204a0c11af1d.png)

## 5. 线性表

**线性表**是由同一类型的数据元素构成的有序序列的线性结构。

线性表中元素的个数就是线性表的长度，表的起始位置称为**表头**，表的结束位置称为**表尾**，当一个线性表中没有元素时，称为**空表**。



线性表一般需要包含以下功能:

- **初始化线性表**:将一个线性表进行初始化，得到一个全新的线性表。
- **获取指定位置上的元素**:直接获取线性表指定位置i上的元素。
- **获取元素的位置**:获取某个元素在线性表上的位置i。
- **插入元素**:在指定位置i上插入一个元素。
- **删除元素**:删除指定位置i上的一个元素。
- **获取长度**:返回线性表的长度。

实现线性表的结构一般有两种

- 一种是顺序存储实现
- 一种是链式存储实现

### 5.1 循序表

基于数组，为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为**顺序表**。

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/f62d1f078e4b55e202cd0e5f9dc3753e.png)

#### 5.1.1 创建顺序表

1. 这里我们可以先定义一个新的结构体类型，将一些需要用到的数据保存在一起，这里我们以`int`类型的线性表为例:

```c
typedef struct List {
    Data *array;     // 实现循序表的底层数组
    int capacity;       // 表示底层数组的容量
    int size;          // 表中的元素数量
} List;
```

2. 编写初始化操作

```c
_Bool init(List *list) {
    list->array = (int *) malloc(sizeof(Data) * 10);    // 申请10个元素的空间
    if (list->array == NULL) {                // 申请失败
        return 0;   
    }
    list->capacity = 10;        // 容量为10
    list->size = 0;         // 元素数量为0
    return 1;
}
```

#### 5.1.2 编写插入的操作

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/5ced7d5327bae6ce0c2d5db93654d54b.png)

```c
_Bool insert(List *list, Data e, int index) {
    if (index < 0 || index > list->size) {    // 如果插入位置不合法
        return 0;
    }
    list->size++;        // 元素数量加1
    if (list->size > list->capacity) {  // 如果元素数量大于容量
        list->capacity *= 2;       // 容量翻倍
        list->array = (int *) realloc(list->array, sizeof(Data) * list->capacity);  // 重新申请空间
    }
    for (int i = list->size-1; i > index; i--) {
        list->array[i] = list->array[i - 1];
    }
    list->array[index] = e;
    return 1;
}
```

测试插入功能

```c
void print(List *list) {
    for (int i = 0; i < list->size; i++) {
        printf("%d\n", list->array[i]);
    }
    printf("\n");
}

int main() {
    List list;
    init(&list);
    insert(&list, 1, 0);
    insert(&list, 2, 0);
    insert(&list, 3, 0);
    insert(&list, 4, 0);
    insert(&list, 5, 0);
    insert(&list, 6, 0);
    print(&list);
    printf("capacity: %d size: %d\n", list.capacity, list.size);
    return 0;
}
```

输出

```
6
5
4
3
2
1

capacity: 10 size: 6
```

#### 5.1.3 编写删除的操作

```c
_Bool delete(List *list, int index) {
    if (index < 0 || index >= list->size) {
        return 0;
    }
    if (list->size < list->capacity / 4) {      // 如果元素数量小于容量的1/4,则容量减半
        list->capacity /= 2;
        list->array = (int *) realloc(list->array, sizeof(Data) * list->capacity);
    }
    for (int i = index; i < list->size - 1; i++) {
        list->array[i] = list->array[i + 1];
    }
    list->size--;
    return 1;
}
```

测试功能

```c
int main() {
    List list;
    srand((unsigned) time(NULL));
    init(&list);
    for (int i = 0; i < 70; ++i) {
        insert(&list, i + 1, i);
    }
    print(&list);
    printf("capacity: %d size: %d\n\n", list.capacity, list.size);
    for (int i = 0; i < 60; ++i) {
        delete(&list, rand() % 50);    // 随机删除
    }
    print(&list);
    printf("capacity: %d size: %d\n\n", list.capacity, list.size);
    return 0;
}
```

输出

```
i: 0 e: 1 i: 1 e: 2 i: 2 e: 3 i: 3 e: 4 i: 4 e: 5
i: 5 e: 6 i: 6 e: 7 i: 7 e: 8 i: 8 e: 9 i: 9 e: 10
i: 10 e: 11 i: 11 e: 12 i: 12 e: 13 i: 13 e: 14 i: 14 e: 15
i: 15 e: 16 i: 16 e: 17 i: 17 e: 18 i: 18 e: 19 i: 19 e: 20
i: 20 e: 21 i: 21 e: 22 i: 22 e: 23 i: 23 e: 24 i: 24 e: 25
i: 25 e: 26 i: 26 e: 27 i: 27 e: 28 i: 28 e: 29 i: 29 e: 30
i: 30 e: 31 i: 31 e: 32 i: 32 e: 33 i: 33 e: 34 i: 34 e: 35
i: 35 e: 36 i: 36 e: 37 i: 37 e: 38 i: 38 e: 39 i: 39 e: 40
i: 40 e: 41 i: 41 e: 42 i: 42 e: 43 i: 43 e: 44 i: 44 e: 45
i: 45 e: 46 i: 46 e: 47 i: 47 e: 48 i: 48 e: 49 i: 49 e: 50
i: 50 e: 51 i: 51 e: 52 i: 52 e: 53 i: 53 e: 54 i: 54 e: 55
i: 55 e: 56 i: 56 e: 57 i: 57 e: 58 i: 58 e: 59 i: 59 e: 60
i: 60 e: 61 i: 61 e: 62 i: 62 e: 63 i: 63 e: 64 i: 64 e: 65
i: 65 e: 66 i: 66 e: 67 i: 67 e: 68 i: 68 e: 69 i: 69 e: 70

capacity: 80 size: 70

i: 0 e: 13 i: 1 e: 14 i: 2 e: 18 i: 3 e: 19 i: 4 e: 24
i: 5 e: 26 i: 6 e: 30 i: 7 e: 31 i: 8 e: 34 i: 9 e: 35
i: 10 e: 36 i: 11 e: 48 i: 12 e: 63 i: 13 e: 64 i: 14 e: 67
i: 15 e: 70
capacity: 40 size: 16
```

#### 5.1.4 获取和查找元素

1. 获取元素

```c
Data get(List *list, int index) {
    if (index < 0 || index >= list->size) {
        return -1;
    }
    return list->array[index];
}
```

2. 循序查找元素

```c
Data findElem(List *list, Data e) {
    for (int i = 0; i < list->size; i++) {
        if (list->array[i] == e) {
            return i;
        }
    }
    return -1;
}
```

测试功能

```c
int main() {
    List list;
    init(&list);
    for (int i = 0; i < 30; ++i) {
        insert(&list, i + 1, i);
    }
    print(&list);
    int pos = findElem(&list, 10);
    printf("pos: %d", pos);
    return 0;
}
```

输出

```
i: 0 e: 1 i: 1 e: 2 i: 2 e: 3 i: 3 e: 4 i: 4 e: 5
i: 5 e: 6 i: 6 e: 7 i: 7 e: 8 i: 8 e: 9 i: 9 e: 10
i: 10 e: 11 i: 11 e: 12 i: 12 e: 13 i: 13 e: 14 i: 14 e: 15
i: 15 e: 16 i: 16 e: 17 i: 17 e: 18 i: 18 e: 19 i: 19 e: 20
i: 20 e: 21 i: 21 e: 22 i: 22 e: 23 i: 23 e: 24 i: 24 e: 25
i: 25 e: 26 i: 26 e: 27 i: 27 e: 28 i: 28 e: 29 i: 29 e: 30

pos: 9
```

#### 5.1.5 分析

操作上面的顺序表的时间复杂度

- 插入：因为需要将所有元素都向后移动，所以是`o(n)`

- 删除：和插入同理，是`o(n)`
- 查找元素：需要遍历所有元素，是`o(n)`
- 获取元素：`o(1)`

在长度为n的顺序表中，向第i个元素插入一个元素，需要向后移动`n-i`个元素

![image-20230320084650983](https://gitee.com/pepedd864/cdn-repos/raw/master/img/c684c77dfcb9d7f8c54ab2e14a3c6133.png)

### 5.2 链表

链表不同于顺序表，**顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要**，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。**它不需要申请连续的空间，只需要按照顺序连接即可**，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表)。

链表分为带头结点的链表和不带头结点的链表，带头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据:

#### 5.2.1 创建链表

1. 定义结构和初始化函数

```c
typedef struct Node {
    Data data;
    int length;
    struct Node *next;
}Node;

_Bool init(Node *head) {
    head->next = NULL;
    head->length = 0;
    return 1;
}
```

#### 5.2.2 插入元素和遍历元素

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/9a61d10af5cdd620c98e889dd64c2df1.png)

1. 编写插入元素函数

```c
_Bool insert(Node *head, Data e, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head == NULL)   // 判断插入位置是否合法
            return 0;
    }
    Node *newNode = (Node *) malloc(sizeof(Node));
    if (newNode == NULL)    // 判断内存是否分配成功
        return 0;
    newNode->data = e;
    newNode->next = head->next; // 将新节点的next指针指向head的next指针所指向的节点
    head->next = newNode;   // 将head的next指针指向新节点
    return 1;
}
```

2. 编写遍历函数

```c
void print(Node *head) {
    int i = 0;
    while (head->next != NULL) {
        head = head->next;
        printf("i: %d e: %d  ", i, head->data);
        if (i++ && i % 5 == 0)
            printf("\n");
    }
    printf("\n\n");
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    insert(&head, 1, 0);
    insert(&head, 2, 1);
    insert(&head, 3, 2);
    insert(&head, 4, 3);
    insert(&head, 5, 4);
    print(&head);
    return 0;
}
```

输出

```
1
2
3
4
5
```

#### 5.2.3 删除元素

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/c1a2ef70ceb74bcef1190e3fed821c3e.png)

1. 编写删除函数

```c
_Bool delete(Node *head, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head == NULL)   // 判断删除位置是否合法
            return 0;
    }
    if (head->next == NULL) // 判断删除位置是否合法
        return 0;
    Node *tmp = head->next;         // 保存被删节点的地址
    head->next = head->next->next;  // 指向被删元素的下一个节点
    free(tmp);                      // 释放被删节点的内存
    return 1;
}
```

2. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 23; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    for (int i = 0; i < 13; ++i) {
        delete(&head, 0);
    }
    print(&head);
    return 0;
}
```

输出

```
i: 0 e: 1  i: 1 e: 2  i: 2 e: 3  i: 3 e: 4  i: 4 e: 5
i: 5 e: 6  i: 6 e: 7  i: 7 e: 8  i: 8 e: 9  i: 9 e: 10
i: 10 e: 11  i: 11 e: 12  i: 12 e: 13  i: 13 e: 14  i: 14 e: 15
i: 15 e: 16  i: 16 e: 17  i: 17 e: 18  i: 18 e: 19  i: 19 e: 20
i: 20 e: 21  i: 21 e: 22  i: 22 e: 23

i: 0 e: 14  i: 1 e: 15  i: 2 e: 16  i: 3 e: 17  i: 4 e: 18
i: 5 e: 19  i: 6 e: 20  i: 7 e: 21  i: 8 e: 22  i: 9 e: 23

```

#### 5.2.4 获取和查找元素

1. 获取函数

```c
Data get(Node *head, int index) {
    if (index < 0)
        return INT_MAX;
    for (; head->next && index; index--) {  // 判断index是否合法
        head = head->next;
        if (head->next == NULL)             // 如果发生越界返回INT_MAX
            return INT_MAX;
    }
    return head->next->data;
}
```

2. 查找函数

```c
int findElem(Node *head, Data e) {
    for (int i = 0; head->next; i++, head = head->next) {
        if (head->next->data == e) {
            return i;
        }
    }
    return -1;
}
```

#### 5.2.5 获取长度

```c
int len(Node *head) {
    int i = 0;
    for (; head->next; i++, head = head->next);
    return i;
}
```

#### 5.2.6 分析

操作链表的事件复杂度

- 插入，需要向前循环查找节点，复杂度为`o(n)`，但是没有赋值操作，效率比顺序表高
- 删除，和插入同理，事件复杂度为`o(n)`
- 获取元素，也需要循环遍历，复杂度为`o(n)`

什么时候用顺序表、链表

- 通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。
- 而顺序表在插入元素时就显得有些戏肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。

### 5.3 双向链表

为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针:

#### 5.3.1 创建双向链表

```c
typedef struct Node {
    Data data;
    struct Node *prev;
    struct Node *next;
} Node;

void init(Node *head) {
    head->prev = head->next = NULL;
}
```

#### 5.3.2 插入元素

1. 编写插入函数

```c
_Bool insert(Node *head, Data e, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        if (head->next == NULL)
            return 0;
        head = head->next;
    }
    Node *newNode = (Node *) malloc(sizeof(Node));
    if (newNode == NULL)
        return 0;
    newNode->data = e;
    // 插入节点
    if (head->next != NULL) {   // 插入的不是最后一个节点
        newNode->next = head->next;
        head->next->prev = newNode;
    } else {
        newNode->next = NULL;
    }
    head->next = newNode;
    newNode->prev = head;
    return 1;
}
```

2. 编写遍历函数(顺序和逆序)

```c
void print(Node *head) {
    int i = 0;
    printf("\nsequence:\n");
    for (; head->next; i++, head = head->next) {
        printf("i: %d e: %d\t|| ", i, head->next->data);
        if (i && (i + 1) % 5 == 0)
            printf("\n");
    }
    printf("\nreverse:\n");
    for (i--; head->prev; --i, head = head->prev) {
        printf("i: %d e: %d\t|| ", i, head->data);
        if (i && i % 5 == 0)
            printf("\n");
    }
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 30; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    return 0;
}
```

输出

```
sequence:
i: 0 e: 1       || i: 1 e: 2    || i: 2 e: 3    || i: 3 e: 4    || i: 4 e: 5    ||
i: 5 e: 6       || i: 6 e: 7    || i: 7 e: 8    || i: 8 e: 9    || i: 9 e: 10   ||
i: 10 e: 11     || i: 11 e: 12  || i: 12 e: 13  || i: 13 e: 14  || i: 14 e: 15  ||
i: 15 e: 16     || i: 16 e: 17  || i: 17 e: 18  || i: 18 e: 19  || i: 19 e: 20  ||
i: 20 e: 21     || i: 21 e: 22  || i: 22 e: 23  || i: 23 e: 24  || i: 24 e: 25  ||
i: 25 e: 26     || i: 26 e: 27  || i: 27 e: 28  || i: 28 e: 29  || i: 29 e: 30  ||

reverse:
i: 29 e: 30     || i: 28 e: 29  || i: 27 e: 28  || i: 26 e: 27  || i: 25 e: 26  ||
i: 24 e: 25     || i: 23 e: 24  || i: 22 e: 23  || i: 21 e: 22  || i: 20 e: 21  ||
i: 19 e: 20     || i: 18 e: 19  || i: 17 e: 18  || i: 16 e: 17  || i: 15 e: 16  ||
i: 14 e: 15     || i: 13 e: 14  || i: 12 e: 13  || i: 11 e: 12  || i: 10 e: 11  ||
i: 9 e: 10      || i: 8 e: 9    || i: 7 e: 8    || i: 6 e: 7    || i: 5 e: 6    ||
i: 4 e: 5       || i: 3 e: 4    || i: 2 e: 3    || i: 1 e: 2    || i: 0 e: 1    ||
```

#### 5.3.3 删除元素

1. 编写删除函数

```c
_Bool delete(Node *head, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head->next == NULL)
            return 0;
    }
    if (head->next == NULL)
        return 0;
    Node *tmp = head->next;
    // 将节点从逻辑上删除
    if (head->next->next)       // 待删除节点的后继节点是否存在
    {
        head->next->next->prev = head;
        head->next = head->next->next;
    } else {
        head->next = NULL;
    }
    // 释放内存
    free(tmp);
    return 1;
}
```

2. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 13; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    delete(&head, 12);
    print(&head);
    return 0;
}
```

```
sequence:
|i: 0 e: 1      | |i: 1 e: 2    | |i: 2 e: 3    | |i: 3 e: 4    | |i: 4 e: 5    |
|i: 5 e: 6      | |i: 6 e: 7    | |i: 7 e: 8    | |i: 8 e: 9    | |i: 9 e: 10   |
|i: 10 e: 11    | |i: 11 e: 12  | |i: 12 e: 13  |

sequence:
|i: 0 e: 1      | |i: 1 e: 2    | |i: 2 e: 3    | |i: 3 e: 4    | |i: 4 e: 5    |
|i: 5 e: 6      | |i: 6 e: 7    | |i: 7 e: 8    | |i: 8 e: 9    | |i: 9 e: 10   |
|i: 10 e: 11    | |i: 11 e: 12  |
```



#### 5.3.4 循环链表

最后一个节点指向头节点的链表

**// TODO**

## 6. 特殊线性表

### 6.1 栈

栈

- 是一种特殊的线性表，它只能在表尾进行插入和删除操作

#### 6.1.1 创建栈

1. 创建栈

```c
typedef struct Stack {
    Data *data;
    int capacity;
    int top; // 存栈顶的下标
} Stack;

_Bool init(Stack *stack) {
    stack->data = (int *) malloc(sizeof(Data) * 10);
    if (stack->data == NULL)
        return 0;
    stack->capacity = 10;
    stack->top = -1;
    return 1;
}
```

2. 遍历函数

```c
void print(Stack *stack) {
    for (int i = stack->top; i >= 0; --i) {
        printf("+------+\n");
        printf("| %4d |\n", stack->data[i]);
    }
    printf("+------+\n");
    printf("top: %d capacity: %d\n", stack->top, stack->capacity);
}
```



#### 6.1.2 入栈出栈

1. 入栈

```c
_Bool push(Stack *stack, Data e) {
    //判断是否需要扩容
    if (stack->top + 1 == stack->capacity) {
        stack->capacity = stack->capacity + (stack->capacity >> 1); // 容量增加1.5倍
        Data *data = (Data *) realloc(stack->data, sizeof(Data) * stack->capacity);// 重新申请内存
        if (data == NULL)
            return 0;
        stack->data = data;
    }
    stack->data[++stack->top] = e;
    return 1;
}
```

2. 出栈

```c
Data pop(Stack *stack) {
    // 判断是否需要减容
    if (stack->top <= stack->capacity / 2) {
        stack->capacity /= 2;
        Data *data = (Data *) realloc(stack->data, sizeof(Data) * stack->capacity);
        if (data == NULL)
            return INT_MAX;
        stack->data = data;
    }
    return stack->data[stack->top--];
}
```

3. 测试功能

```c
int main() {

    Stack stack;
    init(&stack);
    for (int i = 100; i < 110; ++i) {
        push(&stack, i);
    }
    print(&stack);
    for (int i = 0; i < 5; ++i) {
        printf("%d\n", pop(&stack));
    }
    print(&stack);
    return 0;
}
```

输出

```
+------+
|  109 |
+------+
|  108 |
+------+
|  107 |
+------+
|  106 |
+------+
|  105 |
+------+
|  104 |
+------+
|  103 |
+------+
|  102 |
+------+
|  101 |
+------+
|  100 |
+------+
top: 9 capacity: 10

109
108
107
106
105
+------+
|  104 |
+------+
|  103 |
+------+
|  102 |
+------+
|  101 |
+------+
|  100 |
+------+
top: 4 capacity: 5
```

### 6.2 栈(链表实现)

#### 6.2.1 创建栈

1. 创建栈

 ```c
 typedef struct Node {
     Data data;
     struct Node *next;
 } Node;
 
 void init(Node *head) {
     head->next = NULL;
 }
 ```

2. 遍历函数

```c
void print(Node *head) {
    head = head->next;
    for (; head; head = head->next) {
        printf("+------+\n");
        printf("| %4d |\n", head->data);
    }
    printf("+------+\n");
}
```

#### 6.2.2 入栈出栈

1. 入栈

```c
_Bool push(Node *head, Data e) {
    Node *node = (Node *) malloc(sizeof(Node));
    if (node == NULL)
        return 0;
    node->data = e;
    node->next = head->next;
    head->next = node;
}
```

2. 出栈

```c
Data pop(Node *head) {
    Node *tmp = head->next;
    Data e = tmp->data;
    head->next = head->next->next;
    free(tmp);
    return e;
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 10; ++i) {
        push(&head, i);
    }
    print(&head);
    for (int i = 0; i < 5; ++i) {
        printf("%d\n", pop(&head));
    }
    print(&head);
    return 0;
}
```

输出

```
+------+
|    9 |
+------+
|    8 |
+------+
|    7 |
+------+
|    6 |
+------+
|    5 |
+------+
|    4 |
+------+
|    3 |
+------+
|    2 |
+------+
|    1 |
+------+
|    0 |
+------+
9
8
7
6
5
+------+
|    4 |
+------+
|    3 |
+------+
|    2 |
+------+
|    1 |
+------+
|    0 |
+------+
```

### 6.3 队列

队列(Queue)是一种特殊的线性表

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/0223ff3327548b7a2bc2f51832c33a44.png)

秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出(FIFO，First In, First Out)的数据结构。

顺序表实现方式

1. 假设一开始的时候队列有0个元素，队首和队尾一般都初始都是-1这个位置:

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/992b283a15ceb35e0c7123568e35afcd.png)

2. 此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/9a413d137e1fd68c91bab5e454599227.png)



3. 之后都是以同样的方式进行插入，队尾会一直向后移动

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/4d37a4c1e9d4f99f676d58498138d095.png)

4. 现在我们想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/d06567883020e27b3d693f0b5e0da0b3.png)

5. 看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧?所以一般我们采用循环队列的形式，来实现重复使用一个数组(不过就没办法扩容了，大小是固定的)

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/8fba2e1754975b458b49a9173932286d.png)

6. 我们可以在移动队首队尾指针时，考虑循环的问题，也就是说如果到达了数组尽头，那么就直接从数组的前面重新开始计算，这样就相当于逻辑上都循环了，队首和队尾指针在一开始的时候都指向同一个位置，每入队一个新的元素，依然是先让队尾后移一位，在所指向位置插入元素，出队同理。

7. 由于队首指针和队尾指针重合时表示队列为空，所以我们只能舍弃一个存储单元，当队尾距离队首一个单元的时候，表示队列已满。

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/b45e19f998db39d1cdac88d7e58d60ef.png)





#### 6.3.1 创建队列

使用的是循环队列

1. 创建队列

```c
typedef int Data;

typedef struct Queue {
    Data *data;
    int capacity; // 容量
    int rear, front; // 队尾，队头

} Queue;

/***
 * @brief 初始化队列
 * @param queue 队列
 * @return
 */

_Bool initQueue(Queue *queue) {
    queue->data = malloc(sizeof(Data) * 10);
    if (queue->data == NULL) {
        return 0;
    }
    queue->capacity = 10;
    queue->rear = queue->front = 0;
    return 1;
}
```

2. 遍历队列

```c
/***
 * @brief 遍历队列
 * @param queue 队列
 * @return
 */

void print(Queue *queue) {
    int i = queue->front;
    printf("<<<");
    do {
        i = (i + 1) % queue->capacity;
        printf("%d ", queue->data[i]);
    } while (i != queue->rear);
    printf(">>>\n");
}
```



#### 6.3.2 入队出队

1. 入队

```c
/***
 * @brief 入队
 * @param queue 队列
 * @param data 数据
 * @return
 */

_Bool offerQueue(Queue *queue, Data data) {
    int pos = (queue->rear + 1) % queue->capacity;
    if (pos == queue->front) {
        return 0;
    }
    queue->rear = pos;
    queue->data[queue->rear] = data;
    return 1;
}
```

2. 出队

```c
/***
 * @brief 出队
 * @param queue 队列
 * @return
 */

Data pollQueue(Queue *queue) {
    queue->front = (queue->front + 1) % queue->capacity;
    return queue->data[queue->front];
}
```



### 6.4 队列(链表实现)

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/72aed60fe32f6d35744a9de0e82c4387.png)

1. 注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。
2. 当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位:

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/670faef8fb86468504c4c536c66ff29f.png)

3. 出队时，只需要移除队首指向的下一个元素即可

![image-20230405112035236](https://gitee.com/pepedd864/cdn-repos/raw/master/img/4b16a936c139a216f572df4f5bc24e0b.png)



#### 6.4.1 创建队列

1. 创建队列

```c
typedef int Data;

typedef struct LNode {
    Data data;
    struct LNode *next;
} LNode;

typedef struct Queue {
    LNode *front;
    LNode *rear;
} Queue;

/***
 * @brief 初始化队列
 * @param queue 队列
 * @return
 */

_Bool initQueue(Queue *queue) {
    LNode *node = malloc(sizeof(LNode));
    if (node == NULL) {
        return 0;
    }
    queue->front = queue->rear = node;
    return 1;
}
```

2. 遍历队列

```c
/***
 * @brief 遍历队列
 * @param queue 队列
 */

void print(Queue *queue) {
    printf("<<<");
    LNode *node = queue->front->next;
    while (node != NULL) {
        printf("%d ", node->data);
        node = node->next;
    }
    printf(">>>\n");
}
```



#### 6.4.2 入队出队

1. 入队

```c
/***
 * @brief 入队
 * @param queue 队列
 * @param data 数据
 * @return
 */

_Bool offerQueue(Queue *queue, Data data) {
    LNode *node = malloc(sizeof(LNode));
    if (node == NULL) {
        return 0;
    }
    node->data = data;
    queue->rear->next = node;
    queue->rear = node;
    queue->rear->next = NULL;
    return 1;
}
```

2. 出队

```c
_Bool isEmpty(Queue *queue) {
    return queue->front == queue->rear;
}

/***
 * @brief 出队
 * @param queue 队列
 */

Data pollQueue(Queue *queue) {
    if (isEmpty(queue)) {
        return INT_MAX;
    }
    LNode *node = queue->front->next;
    Data data = node->data;
    queue->front->next = node->next;
    if (queue->rear == node) {
        queue->rear = queue->front;
    }
    free(node);
    return data;
}
```



## 7. 树形结构

### 7.1 树和森林

**树**

<img src="https://gitee.com/pepedd864/cdn-repos/raw/master/img/de56c1d79950fb711c7d88dfd9aa3f16.png" style="zoom:50%;" />

可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为**树**(Tree)注意分支只能向后单独延伸，之后就分道扬镳了，**不能与其他分支上的结点相交**!

- 我们一般称位于最上方的结点为树的**根结点**（Root）因为整棵树正是从这里开始延伸出去的。
- 每个结点连接的子结点数目(分支的数目)，我们称为结点的**度**(Degree)，而各个结点度的最大值称为树的度。
- 每个结点延伸下去的下一个结点都可以称为一棵**子树**（SubTree）比如结点B及其之后延伸的所有分支合在一起，就是一棵A的子树。
- 每个**结点的层次**（Level）按照从上往下的顺序，树的根结点为1，每向下一层+1，比如G的层次就是3，整棵树中所有结点的最大层次，就是这颗树的**深度**（Depth），比如上面这棵树的深度为4，因为最大层次就是4

节点之间的称谓

- 与当前节点直接向下连接的节点为**子节点**，相反直接向上连接的节点就是**父节点**
- 没有任何子节点（节点度为0）的节点为**叶子节点**
- 父节点为同一个的节点之间称**兄弟节点**
- 向上直到根节点的所有节点，称为**祖先节点**



**森林**

m(m>0)棵树的集合称为森林

### 7.2 二叉树

#### 7.2.1 二叉树概念

**二叉树**（Binary Tree）

- 度最大为2
- 有左右之分，称为**左子树**、或者**右子树**

几种基本形态

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/172a9eb1329ef7a1e07d8d8547e502a1.png)

二叉树的称称谓

- **满二叉树**，整颗树都很饱满，没有出现度为1的节点

<img src="https://gitee.com/pepedd864/cdn-repos/raw/master/img/073b101e41fc912e5d38b9f27df8f715.png" style="zoom:50%;" />

- **完全二叉树**，只有最后一层空缺，且所有叶子节点都是从左到右的顺序排列，满二叉树就饿完全二叉树

<img src="https://gitee.com/pepedd864/cdn-repos/raw/master/img/86624b67c66ff9f5a40ee0ed897f433e.png" style="zoom:50%;" />

#### 7.2.2 树和森林的转换

二叉树和树、森林之间是可以互相转换的

##### 7.2.2.1 树转换为二叉树

1. 方式一：兄弟节点转为右子节点，子节点转为左子节点
   - 最左边孩子结点 -> 左子树结点 (左孩子)
   - 兄弟结点 -> 右子树结点 (右孩子)

以下面这棵树为例

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/ae5706be260968a388935b01e1c1bf5e.png)

我们优先从左边开始看，B、F、G都是A的子结点，根据上面的规律，我们将B作为左子树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/0ce56677735b14e5c79ae8999cc19c13.png)

接着继续从左往右看，由于F是B的兄弟结点，那么根据规律，F作为B的右子树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/4178c3d4abe400a0f2847067b8ef2b6e.png)

接着是G，G是F的兄弟结点，那么G继续作为F的右子树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/b9a242ed11c0b3817650fabac8b493b1.png)

我们接着来看第三排，依然是从左往右，C是B的子节点，所以C作为B的左子树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/b402c9e0a9efafb0e66dd7b8132c998d.png)

接着，D是C的兄弟结点，那么D就作为C的右子树了

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/85f757dd3f97fb5b461d3c5ab946e2b1.png)

此时还有一个H结点，他是G的子节点，所以直接作为G的左子树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/68a1da08a4e178d5fe6a73e14fe28ee3.png)

现在只剩下最后一排了，E是D的子节点，K是H的子节点，所以最后就像这样了

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/2d53a930a49867de8f54605a89c3ff11.png)



2. 方式二：兄弟节点之间相互连线，擦除右节点的连线，拉直树即可

将所有兄弟结点连起来(橙色横线)

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/3dab6c993d40020e7f66354c9e1a9d94.png)

接着擦掉除了最左边结点以外的连线

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/84e8003af6da72b26eb3ff6ebeb3b18c.png)

所有的黑色连线偏向左边，橙色连线偏向右边

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/0d4d56296bd5282fa4c6d4fa9b0411d5.png)



##### 7.2.2.2 二叉树转为树

- 反推即可

##### 7.2.2.3 森林转为二叉树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/712cb9014248f2fb50fb99fc60292325.png)

首先，还是按照二叉树转换规则，将森林中所有树转换为二叉树，接着我们只需要依次连接即可

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/d79740ca4a9039bcce1f8eb4b3fb5aed.png)

##### 7.2.2.4 从树转为二叉树和从森林转为二叉树的区别

- 从树转为二叉树，二叉树没有右子树

- 从森林转为二叉树，二叉树有右子树

#### 7.2.3 二叉树数学性质

**五个性质**

- **性质一：**第$i$层的最大节点数量为$2^{i-1}$个，比如二叉树的第一层只有一个根节点，也就是$2^0=1$，而二叉树的第三层可以有$2^2=4$个节点
- **性质二：**对于一棵深度为$k$的二叉树，可以具有的最大节点数为：

$$
n=2^0+2^1+2^2+...+2^{k-1}
$$

每层节点的数量，组成了等比数列，公比为2
$$
s_n=\frac{a_1\times{(1-q_n)}}{1-q}=\frac{1\times{(1-2^k)}}{1-2}=-(1-2^k)=2^k-1
$$
所以一棵深度为$k$的二叉树的最大节点数量为$n=2^k-1$，节点边数为$E=n-1$

- **性质三：**假设一棵二叉数中度为0、1、2的节点数量分别为$n_0、n_1、n_2$，由于一棵二叉树中只有这三种类型的节点，那么可以直接得到节点总数

$$
n=n_0+n_1+n_2
$$

因为每个结点有且仅有一条变与父节点相连，那么边数之和就可以表示为
$$
E=n_1+2n_2
$$
度为1的结点有一条边，度为2的结点有两条边，度为0的结点没有，加在一起就是整颗二叉树的边数之和，结合**性质二**中推导的结果，可以得到另一种计算结点总数的方式
$$
E=n-1=n_1+2n_2
$$

$$
n=n_1+2n_2+1
$$

在结合第一个公式
$$
n=n_0+n_1+n_2=n_1+2n_2+1
$$
**综上，对于任何一棵二叉树，如果其叶子结点个数为$n_0$，度为2的结点个数为$n_2$，那么二者满足以下公式**
$$
n_0=n_2+1
$$


- **性质四：**完全二叉树除了最后一层有空缺外，其他层数都是饱满的，假设这棵二叉树为满二叉树，那么根据我们前面得到的性质，假设层数为$k$，那么结点数量为:$n=2^k-1$，根据完全二叉树的性质，最后一层可以满可以不满，那么一棵完全二叉树结点数n满足:

$$
2^{k-1}-1<n<=2^k-1
$$

因为$n$肯定是一个整数，那么可以写成
$$
2^{k-1}<=n<=2^k-1
$$
只看左边的不等式，我们对两边取对数，得到
$$
k-1<=\log_2n
$$
**综上所属，一棵具有$n$个结点的完全二叉树深度为**
$$
k=\lfloor\log_2n\rfloor+1
$$


- **性质五：**一颗有$n$个结点的完全二叉树，由性质四得到深度为$k= \lfloor{log_2n}\rfloor+1$现在对于任意一个结点$i$，结点的顺序为从上往下，从左往右:
  - 对于一个拥有左右孩子的结点来说，**其左孩子为$2i$ ，右孩子为$2i + 1$**。
  - 如果$i = 1$，那么此结点为二叉树的根结点，**如果$i>1$，那么其父结点就是$\lfloor{i/2}\rfloor$**，比如第3个结点的父结点为第1个节点,也就是根结点。
  - **如果$2i > n$，则结点主没有左孩子**，比如下面图中的二叉树，$n$为5，假设此时$i = 3$，那么$2i = 6 > n = 5$说明第三个结点没有左子树。
  - **如果$2i +1 > n$，则结点$i$没有右孩子**。

<img src="https://gitee.com/pepedd864/cdn-repos/raw/master/img/f12797f825c11ed0d31c0b11249ea80c.png" alt="image-20230323232747845" style="zoom:50%;" />



#### 7.2.4 二叉树练习题

##### 7.2.4.1 练习题一

**由三个结点可以构造出多少种不同的二叉树？**

- 手画可以得出是5个
- 如果求N个结点，可以使用动态规划的方法
  - 假设现在只有一个结点或者没有结点，那么只有一种，$h(0)=h(1)=1$
  - 假设现在有两个结点，那么其中一个拿来做根节点，剩下这一个可以左边可以右边，要么左边零个结点右边一个结点，要么左边一个结点右边零个结点，所以说$h(2)=h(1)\times h(0) + h(0)\times h(1)=2$
  - 假设现在有三个结点，那么依然是其中一个拿来做根节点，剩下的两个结点情况就多了，要么两个都在左边，两个都在右边，或者一边一个，所以说$h(3)=h(2)\times h(0) + h(1)\times h(1) + h(0)\times h(2)=5$
  - **我们发现，他说非常有规律的，N每+1，项数多一项，所以我们只需要按照规律把所有情况的结果相加就行了**，我们按照上面推到的结果，编写代码

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n); // 读入需要计算的二叉树层数
    int dp[n + 1];
    dp[0] = dp[1] = 1; // 没有结点或是只有一个结点的二叉树只有一种情况
    for (int i = 2; i <= n; i++) {
        dp[i] = 0; // 初始化为0
// 内层循环是为了计算所有情况，比如i等于3时，那么就从j = 0开始，计算dp[0]和dp[2]的结果，
// 再计算dp[1]和dp[1]的结果，最后计算dp[2]和dp[0]的结果
        for (int j = 0; j < i; j++) {
            dp[i] += dp[i - j - 1] * dp[j];
        }
    }
    printf("%d\n", dp[n]); // 输出n层二叉树的情况数
    return 0;
}
```

> 求出结果序列为：1、1、2、5、14、42、132...，这种类型的数列我们称为**卡特兰数**，以中国蒙古族数学家明安图(1692-1763)和比利时的数学家欧仁·查理·卡塔兰(1814-1894)的名字来命名，**它的通项公式为**:

$$
C_n=\frac{1}{n+1}C^n_{2n}=\frac{1}{n+1}\times \frac{(2n)!}{n!\times (2n-n)!}=\frac{(2n!)}{n!\times (n+1)!}
$$

所以不需要动态规划了，直接一个算式解决问题

```c
#include <stdio.h>

int fac(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * fac(n - 1);
    }
}

int main() {
    int n;
    scanf("%d", &n);
    printf("%d", fac(2 * n) / (fac(n) * fac(n + 1)));
    return 0;
}
```



##### 7.2.4.2 练习题二

**一棵完全二叉树有1001个结点，其中叶子结点的个数为？**

> 既然是完全二叉树，那么最下面这一排肯定是按顺序排的，并且上面各层应该是排满了的，那么我们先求出层数，根据性质四：

$$
k = \lfloor log_2n\rfloor + 1 = 9 + 1 = 10
$$

> 所以此二叉树的层数为10，也就是说上面9层都是满满当当的，最后一层不满，那么根据性质二，我们求出前9层的结点数：

$$
n = 2^k - 1 = 511
$$

> 那么剩下的结点就都是第10层的了，等到第10层所有叶子结点数量$=1001-511=490$，因为第10层并不满，剩下的叶子第9层也有，所以最后我们还需要求出第9层的叶子结点数量，先计算第9层的所有结点数量

$$
n=2^{i-1}=256
$$

> 接着我们需要去掉那些第9层度为1和度为2的结点，其实只需要让第10层的叶子结点除以2即可

$$
n=(490+1)/2=245
$$

> 注意在除的时候+1，因为有可能会出现一个度为1的结点，此时也需要剔除，所以说+1变成偶数这样才可以正确得到结果。最后剔除这些结点，道道最终结果

$$
n_0=256-245+490=501
$$



##### 7.2.4.3 练习题三

**深度为h的满m叉树的第k层有多少个结点？**

- 满二叉树性质

$$
n=2^{i-1}
$$

> m叉树，以三叉树为例，每向下一层，就划分三个孩子结点出来，每一层的最大结点数依次为：1、3、9、27...

所以满m叉树的第k层的结点数：
$$
n=m^{k-1}
$$


##### 7.2.4.4 练习题四

**一棵有1025个结点的二叉树的层数k的取值范围是？**

>  根据性质四$k=\lfloor\log_2n\rfloor+1$ ，得到最小深度为11，最大深度就是1025，所以$k$的范围是$11-1025$



##### 7.2.4.5 练习题五

**将一棵树转换为二叉树时，根结点的右边连接的是？**

> 根据我们前面总结的性质，树转换为二叉树之后，根结点一定没有右子树，所以为空



#### 7.2.5 代码实现二叉树

二叉树的存储形式也可以使用我们前面的两种方式，**一种是使用数组进行存放**，**还有一种就是使用链式结构**只不过之前链式结构需要强化一下才可以表示为二叉树。

##### 7.2.5.1 定义二叉树和初始化二叉树

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/baae7e2bd458391a731474ed329abe2e.png)

1. 定义二叉树

```c
typedef char Data;

typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
} TN;

/***
 * @brief 二叉树的创建
 * @return TN* 返回二叉树的根节点
 */
TN *createTree() {
    TN *root = malloc(sizeof(TN));
    Data data = 0;
    root->data = data;
    root->left = NULL;
    root->right = NULL;
    return root;
}
```

2. 向二叉树传值

```c
int main() {
    TN *a = createTree();
    a->data = 'a';
    TN *b = createTree();
    b->data = 'b';
    TN *c = createTree();
    c->data = 'c';
    TN *d = createTree();
    d->data = 'd';
    TN *e = createTree();
    e->data = 'e';
    
    a->left = b;
    a->right = c;
    b->left = d;
    b->right = e;
    printf("%c", a->left->right->data);
    return 0;
}
```



##### 7.2.5.2 遍历二叉树

由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：**前序遍历、中序遍历、后序遍历、层序遍历**。不同的访问方式输出的结点顺序也不一样。



###### 7.2.5.2.1 前序遍历

前序遍历是一种勇往之前的方式，走到哪就遍历到哪里，先走左边再走右边，比如下面这个图，首先会从根结点开始：

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/ec8d81841bbe04a83bff5df5521e7713.png)

先从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完了之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：`ABDECF`

即：

1. 打印节点
2. 遍历左子树
3. 遍历右子树

```c
/***
 * @brief 二叉树的前序遍历
 * @param curr 当前节点
 */

void preOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    printf("%c", curr->data);
    preOrder(curr->left); // 先走左边
    preOrder(curr->right); // 再走右边
}
```

```
abdecf
```



**使用循环和栈来实现前序遍历**

- 一路向左，不断入栈，直到结点为NULL
- 到NULL后，出栈，看有没有右子树，如果没有就继续出栈，知道遇到有右子树的为止
- 拿到右子树后，从右子树开始，重复上述步骤，知道栈清空

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/1463c902a25897f9a0280bced702e1c2.png)

依然从根节点A出发，不断遍历左子树，沿途打印结果并将结点丢入栈中

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/87cf96932e9233d9b7e8f3c65329e229.png)

当遍历到D结点时，没有左子树了，此时将栈顶结点D出栈，发现没有右节点，继续出栈，得到B结点，接着得到当前结点的右孩子E结点，然后重复上述步骤:

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/4c90447bd003d73470551a7bd30931b4.png)

接着发现E也没有左子树了，同样的，又开始出栈，此时E没有右子树，接着看A，A有右子树，所以继续从C开始，重复上述步骤:

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/b9b265f990defa7d6b2011dac9a16ccb.png)

由于C之后没有左子树，那么就出栈获取右子树，此时得到结点F，继续重复上述步骤:

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/bd4d14e5d325042fed5cada1c87fa5e4.png)

最后F出栈，没有右子树了，栈空，结束。



###### 7.2.5.2.2 中序遍历

中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/06883887d9b3ee150bf6790ae7eb56fc.png)

首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。

1. 遍历左子树
2. 打印结点
3. 遍历右子树

```c
/***
 * @brief 二叉树的中序遍历
 * @param curr 当前节点
 */

void inOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    inOrder(curr->left); // 先走左边
    printf("%c", curr->data);
    inOrder(curr->right); // 再走右边
}
```

```
dbeacf
```



###### 7.2.5.2.3 后序遍历

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/4301329fb00c3d121afd79bdb404d2f8.png)

首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。|

1. 遍历左子树
2. 遍历右子树
3. 打印结点

```c
/***
 * @brief 二叉树的后序遍历
 * @param curr 当前节点
 */
void postOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    postOrder(curr->left); // 先走左边
    postOrder(curr->right); // 再走右边
    printf("%c", curr->data);
}
```

```
debfca
```



###### 7.2.5.2.4 层序遍历

这个遍历方式是人最容易理解的方式，一层一层从左到右的遍历

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/c48ad4361581516d18a67c0080b4dbe0.png)

我们可以利用队列来实现层序遍历，首先将根节点存入队列中，接着循环执行以下步骤

- 进行出队操作，得到一个结点，并打印结点的值
- 将此结点的左右孩子结点依次入队
- 不断重复以上步骤，直到队列为空

首先A在队首

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/e378415a2e83b8ae3d773a1bef655c68.png)

接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/1f4257257e8208f43b1424d91b2a7a80.png)

现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/c67c582ffe5cb99c0d05fb22a2149585.png)

现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队

![](https://gitee.com/pepedd864/cdn-repos/raw/master/img/f029ec65005bb2650cffead3b8b057f4.png)

代码

```c++
#include <bits/stdc++.h>

using namespace std;
typedef char Data;
typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
    explicit TreeNode(Data data): data(data), left(nullptr), right(nullptr) {}
} TreeNode;

void levelOrder(TreeNode *root) {
    if (!root) return;

    queue<TreeNode *> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode *curr = q.front();
            q.pop();
            cout << curr->data << " ";
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        cout << endl;
    }
}

int main() {
    auto *root = new TreeNode('A');
    root->left = new TreeNode('B');
    root->right = new TreeNode('C');
    root->left->left = new TreeNode('D');
    root->left->right = new TreeNode('E');
    root->right->left = new TreeNode('F');
    root->right->right = new TreeNode('G');
    levelOrder(root);
    return 0;
}
```





### 7.3 高级树结构

#### 7.3.1 线索化二叉树

一棵二叉树的某些结点会存在`NULL`的情况，我们可以利用这些为`NULL`的指针，将其**线索化为某一种顺序遍历的指向下一个按顺序的结点的指针**，这样我们在进行遍历的时候，就会很方便了。

例如，一棵二叉树的前序遍历如下

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/2fa3cbed788d738d0feba63b6f3233a6.png)

我们就可以将其进行线索化，首先还是按照前序遍历的顺序依次寻找:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/7276a502577cd40d984ad388bfa1e8f5.png)

线索化的规则为:

- 结点的左指针，指向其当前遍历顺序的前驱结点。
- 结点的右指针，指向其当前遍历顺序的后继结点。

所以在线索化之后，G的指向情况如下:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/b1ff1e93bd9185ece7cf32bcc0897724.png)

这样，G原本两个为`NULL`的指针就被我们利用起来了，但是现在有一个问题，我们怎么知道，某个结点的指针到底是指向的其左右孩子，还是说某种遍历顺序下的前驱或是后继结点呢?所以，我们还需要分别为左右添加一个标志位，来表示左右指针到底指向的是孩子还是遍历线索:

```c++
typedef char Data;

typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
    int leftTag, rightTag; // 标志位，如果为1表示这边指针指向的是线索，不为1就是正常孩子结点
} TreeNode;
```

接着是H结点，同样的，因为H结点的左右指针都是`NULL`，那么我们也可以将其线索化:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/92610813d853e88674c60e95b517f2e0.png)

接着我们来看结点E，这个结点只有一个右孩子，没有左孩子，左孩子指针为`NULL`，我们也可以将其线索化:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/41f424a0263ed18cbc766422ec61d183.png)

最后，整棵二叉树完成线索化之后，除了遍历顺序的最后一个结点没有后续之外，其他为`NULL`的指针都被利用起来了:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/99bed6258646e8864fed0549ee6c91c0.png)

我们可以发现，在利用上那些为`NULL`的指针之后，当我们再次进行前序遍历时，我们不需要再借助栈了，而是可以一路向前。

这里我们弄一个简单一点的线索化二叉树，来尝试对其进行遍历:

![](https://raw.githubusercontent.com/pepedd864/cdn-repos/main/img/9569226ec6c13bf8ec5cd4563d4f931b.png)

1. 创建节点

```c++
TreeNode *createNode(Data data) {
    auto *node = (TreeNode *) malloc(sizeof(struct TreeNode));
    node->data = data;
    node->left = node->right = nullptr;
    node->leftTag = node->rightTag = 0;
    return node;
}

int main() {
    TreeNode *root = createNode('A');
    root->left = createNode('B');
    root->right = createNode('C');
    root->left->left = createNode('D');
    root->left->right = createNode('E');

    return 0;
}
```

