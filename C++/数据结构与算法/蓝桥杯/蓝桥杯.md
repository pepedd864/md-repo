

## 1. 蓝桥杯规则

1. 组别

   - C/C++程序设计分为：研究生组、大学 A 组、大学 B 组和大学 C 组。
   - Java 软件开发分为：研究生组、大学 A 组、大学 B 组和大学 C 组。
   - 每位选手只能申请参加其中一个组别的竞赛。各个组别单独评奖。
   - 研究生只能报研究生组。
   - 重点本科院校（985、211）本科生、只能研究生组或大学 A 组。
   - 其它本科院校本科生可报大学 B 组及以上组别。
   - 其它高职高专院校可自行选择报任意组别。
2. 竞赛赛程

   - 省赛时长：4 小时。
   - 决赛时长：4 小时。
   - 详细赛程安排以组委会公布信息为准。
3. 竞赛形式

   - 原则上采用线下比赛的方式，如因疫情等原因无法线下比赛的选手将采取线上比赛的 方式。

     3.1  线下比赛：

     - 个人赛，一人一机，全程机考。
     - 选手机器通过局域网连接到各个赛场的竞赛服务器。
     - 选手答题过程中无法访问互联网，也不允许使用本机以外的资源（如 USB 连接）。
     - 选手将答案提交到比赛系统中，超过比赛时间将无法提交。
     - 竞赛系统以“服务器-浏览器”方式发放试题、回收选手答案。

     3.2 线上比赛：

     - 个人赛，自备机器和自行安装比赛环境。
     - 选手机器通过浏览器输入准考证上的线上比赛网址进行登录比赛。
     - 选手将答案提交到比赛系统中，超过比赛时间将无法提交。
     - 选手须按照线上比赛手册要求准备相关软件、硬件和网络，并保证遵守线上比赛手册上 的要求进行比赛，不得违规作弊。
     - 线上比赛手册计划于 2023 年 3 月在大赛官网发布。
4. 参赛选手机器环境

   - 选手机器配置：
     - X86 兼容机器，内存不小于 4G，硬盘不小于 60G
     - 操作系统：Windows7、Windows8、Windows10 或 Windows11
   - C/C++语言开发环境：
     - Dev-cpp 5.11 （支持 C++11 标准）
     - C/C++ API 帮助文档
   - Java 语言开发环境：
     - JDK 1.8
     - Eclipse-java-2020-06
     - API 帮助文档
5. 试题形式

   - 竞赛题目完全为客观题型，具体题型及题目数量以正式比赛时赛题为准。根据选手所提 交答案的测评结果为评分依据。

   5.1 结果填空题

   - 题目描述一个具有确定解的问题。要求选手对问题的解填空。 不要求解题过程，不限制解题手段（可以使用任何开发语言或工具，甚至是手算），只要 求填写最终的结果。 最终的解是一个整数或者是一个字符串，最终的解可以使用 ASCII 字符表达。

   5.2. 编程大题

   - 题目包含明确的问题描述、输入和输出格式，以及用于解释问题的样例数据。
   - 编程大题所涉及的问题一定是有明确客观的标准来判断结果是否正确，并可以通过程序 对结果进行评判。
   - 选手应当根据问题描述，编写程序来解决问题，在评测时选手的程序应当从标准输入读 入数据，并将最终的结果输出到标准输出中。
   - 在问题描述中会明确说明给定的条件和限制，明确问题的任务，选手的程序应当能解决 在给定条件和限制下的所有可能的情况。
   - 选手的程序应当具有普遍性，不能只适用于题目的样例数据。
   - 为了测试选手给出解法的性能，评分时用的测试用例可能包含大数据量的压力测试用例， 选手选择算法时要尽可能考虑可行性和效率问题。
6. 试题考查范围

   - 试题考查选手解决实际问题的能力，对于结果填空题，选手可以使用手算、软件、编程 等方法解决，对于编程大题，选手只能编程解决。
   - 竞赛侧重考查选手对于算法和数据结构的灵活运用能力，很多试题需要使用计算机算法 才能有效的解决。
   - 考查范围包括：以下范围中标 `*`的部分只限于 C/C++研究生组、C/C++大学 A 组、Java 研 究生组、Java 大学 A 组。
   - C/C++程序设计基础：包含使用 C/C++编写程序的能力。该部分不考查选手对某一语法 的理解程度，选手可以使用自己喜欢的语句编写程序。选手可在 C 语言程序中使用标准 C 的库函数，在 C++语言程序中使用标准 C++的库函数（包括 C 库、STL 等）。
   - Java 软件开发基础：包含使用 Java 编写程序的能力。该部分不考查选手对某一语法的 理解程度，选手可以使用自己喜欢的语句编写程序。选手可在程序中使用 JDK 中自带的类， 但不能使用其它的第三方类。
   - 计算机算法：
     - 枚举、排序、搜索、计数、贪心、动态规划、图论、数论、博弈论 `*`、概 率论 `*`、计算几何 `*`、字符串算法等。
   - 数据结构：
     - 数组、对象/结构、字符串、队列、栈、树、图、堆、平衡树/线段树、复杂 数据结构 `*`、嵌套数据结构 `*`等。
7. 答案提交

- 选手只有在比赛时间内提交的答案内容是可以用来评测的，比赛之后的任何提交均无效。 选手应使用考试指定的网页来提交代码，任何其他方式的提交（如邮件、U 盘）都不作为评 测依据。
- 选手可在比赛中的任何时间查看自己之前提交的代码，也可以重新提交任何题目的答案， 对于每个试题，仅有最后的一次提交被保存并作为评测的依据。在比赛中，评测结果不会显 示给选手，选手应当在没有反馈的情况下自行设计数据调试自己的程序。
- 对于每个试题，选手应将试题的答案内容拷贝粘贴到网页上进行提交。
- 程序中应只包含计算模块，不要包含任何其他的模块，比如图形、系统接口调用、系统 中断等。对于系统接口的调用都应通过标准库来进行。
- 程序中引用的库应该在程序中以源代码的方式写出，在提交时也应当和程序的其他部分 一起提交。

8. 评分

   - 全部使用机器自动评分。
   - 对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格 式错误或有多余内容时不得分。
   - 对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。 选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程 序的输出与正确答案相匹配，则选手获得该评测数据的分数。
   - 评测使用的评测数据一般与试题中给定的样例输入输出不一样，因此建议选手在提交程 序前使用不同的数据测试自己的程序。
   - 提交的程序应严格按照输出格式的要求来输出，包括输出空格和换行的要求。如果程序 没有遵循输出格式的要求将被判定为答案错误。请注意，程序在输出的时候多输出了内容也 属于没有遵循输出格式要求的一种，所以在输出的时候请不要输出任何多余的内容，比如调 试输出。
   - C/C++选手请务必选择正确的编译器，如果编译器选择错误，可能导致编译不通过而得 0 分。C/C++选手请务必让主函数的返回值为 0，当返回非 0 时会认为程序执行错误而得 0 分。
   - Java 选手请务必不要使用 package 语句，并且确保自己的主类名称为 Main，否则会导 致评测系统运行时找不到主类而得 0 分。
   - C/C++选手所有依赖的函数必须明确地在源文件中#include ，不能通过工程设置而 省略常用头文件。Java 选手如果程序中引用了类库，在提交时必须将 import 语句与程序的 其他部分同时提交。只允许使用 Java 自带的类库。
9. 样题

   - 样题 1：矩形切割（结果填空题）

     【问题描述】 小明有一些矩形的材料，他要从这些矩形材料中切割出一些正方形。 当他面对一块矩形材料时，他总是从中间切割一刀，切出一块最大的正方形，剩下一块矩形， 然后再切割剩下的矩形材料，直到全部切为正方形为止。 例如，对于一块两边分别为 5 和 3 的材料（记为 5×3），小明会依次切出 3×3、2×2、 1×1、1×1 共 4 个正方形。 现在小明有一块矩形的材料，两边长分别是 2019 和 324。请问小明最终会切出多少个 正方形？

     【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提 交答案时只填写这个整数，填写多余的内容将无法得分。 说明：以上是问题描述的部分，选手做题时可以直接手算答案，即按照题目意思一步一 步切割，最后得到切出的矩形个数，手算可能花费一些时间。如果选手在手算时使用除法等 方式加快速度，时间可能少一些。如果选手编写程序来计算，可以减少手算中出现的失误。 本题答案为：21
   - 样题 2：特别数的和（编程大题）

     【问题描述】 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的 数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？

     【输入格式】 输入一行包含一个整数 n。

     【输出格式】 输出一行，包含一个整数，表示满足条件的数的和。

     【样例输入】 40

     【样例输出】 574

     【评测用例规模与约定】

     对于 20%的评测用例，1≤n≤10。

     对于 50%的评测用例，1≤n≤100。

     对于 80%的评测用例，1≤n≤1000。

     对于所有评测用例，1≤n≤10000。

说明：本题是一道编程题，选手需要编写一个程序来解决问题。以下给出一个参考程序， 选手所编写的其他程序只要能给出正确的结果即可得分。

以下是 C/C++语言的参考代码（此代码对于 C 和 C++两种语言通用，对于 C++语言， 一般会将前面的#include 语句改为对应的 C++库）

```c++
#include <stdio.h>

int main() {
    int n, i, ans = 0;
    scanf("%d", &n);
    for (i = 1; i <= n; ++i) {
        int t = i, ok = 0;
        while (t > 0) {
            int g = t % 10;
            if (g == 2 || g == 0 || g == 1 || g == 9) ok = 1;
            t = t / 10;
        }
        if (ok) ans += i;
    }
    printf("%d\n", ans);
    return 0;
 } 
```

以下是 Java 语言的参考代码

```java
import java.util.*; 
public class Main {
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), ans = 0;
        for (int i = 1; i <= n; ++i) {
            int t = i;
            boolean ok = false;
            while (t > 0) {
                int g = t % 10;
                if (g == 2 || g == 0 || g == 1 || g == 9) ok = true;
                t = t / 10;
            }
            if (ok) ans += i;
        }
        System.out.println(ans);
    }
}
```

10. 其它注意事项

    （1）选手必须符合参赛资格，不得弄虚作假。资格审查中一旦发现问题，则取消其报 名资格；竞赛过程中发现问题，则取消竞赛资格；竞赛后发现问题，则取消竞赛成绩，收回 获奖证书及奖品等，并在大赛官网上公示。

    （2）参赛选手应遵守竞赛规则，赛场纪律，服从大赛组委会的指挥和安排，爱护竞赛 赛场地的设备。

    （3）竞赛采用机器阅卷加少量人工辅助的方式。选手需要特别注意提交答案的形式。 必须仔细阅读题目的输入、输出要求以及示例，不要随意添加不需要的内容。

    （4）使用 Java 语言时，注意主类名必须是：Main，不能使用 package 语句。使用 C/C++ 语言时，注意主函数需要 return 0。

    （5）C 组与 C++组选手提交答案时，一定要注意选择 C、C++或 C++11（即编译器类型）。 因为使用机器阅卷，很可能会因为选手选择了错误的编译器，而使自己代码无法编译通过。

## 2. 字符串类题型

1. 给定一个层数n，输出字母三角形

```c++
// 使用C++ STL库的 string类型可以简化代码
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        // 这里使用拼接字符串的方法
        string space = string(n - i, ' ');
        string ch = string(2 * i - 1, 'A' + i - 1);
        cout << space + ch << endl;
    }
    return 0;
}
```

现在输出一个复杂一些的三角形，输入一个大写字母（A~Z）或者一个数字（1~9），输出如下三角形

```
    A
   ABA
  ABCBA
 ABCDCBA
ABCDEDCBA
```

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    char c;
    cin >> c;
    if (c >= 'A' && c <= 'Z') {
        int n = c - 'A' + 1;
        for (int i = 1; i <= n; i++) {
            cout << string(n - i, ' ');
            for (int j = 1; j <= i; j++) {
                cout << char('A' + j - 1);
            }
            for (int j = i - 1; j >= 1; j--) {
                cout << char('A' + j - 1);
            }
            cout << endl;
        }
    }
    if (c >= '1' && c <= '9') {
        int n = c - '1' + 1;
        for (int i = 1; i <= n; i++) {
            cout << string(n - i, ' ');
            for (int j = 1; j <= i; j++) {
                cout << char('1' + j - 1);
            }
            for (int j = i - 1; j >= 1; j--) {
                cout << char('1' + j - 1);
            }
            cout << endl;
        }
    }
    return 0;
}
```

---

2. 蒜头君最近迷恋上了一款游戏《我的世界(Minecraft) 》，在游戏里面蒜头君可以任意开发资源然后建造各种宏伟的建筑。有一天蒜头君发现了一块荒野的土地上有很多宝藏，蒜头君想在土地上建一栋房子从而把宝藏包围起来。
   假设地图是一个n行m列的方格地图，地图每个格子 `*`代表一个宝藏。比如2行2列的地图如下:

```
**
**
```

蒜头君要建的房子如下

```
+-+-+
|*|*|
+-+-+
|*|*|
+-+-+
```

现在蒜头君告诉你地图的行列数，帮他画出房子的设计图。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int row, col;
    cin >> row >> col;
    for (int i = 1; i <= row * 2 + 1; i++) {
        if (i % 2 == 1) {
            for (int j = 1; j <= col * 2 + 1; j++) {
                if (j % 2 == 1)cout << '+';
                else cout << '-';
            }
        } else {
            for (int j = 1; j <= col * 2 + 1; j++) {
                if (j % 2 == 1)cout << '|';
                else cout << '*';
            }
        }
        cout << endl;
    }
    return 0;
}
```

---

3. 某天，蒜头君和花椰妹在公园里散步，走着走着，我的天!他们各自都捡到了一串漂亮的字符串，然而蒜头君好奇心比较重，他想知道自己的字符串在花椰妹的字符串中出现了多少次，例如花椰妹的字符串为 `abababa`，蒜头君的字符串为 `aba` ，那么蒜头君的字符串在花椰妹的字符串中出现了3次。蒜头君一向比较傲娇，于是向你请教，你可以帮帮他么?

   **输入格式**

   输入包含两行，第一行为花椰妹捡到的字符串，第二行为蒜头君捡到的字符串。两个字符串可能包含除换行、回车、0外的任何字符。两个字符串长度均不大于1000。

   **输出格式**

   请你帮花椰妹找出他的字符串里出现了多少次蒜头君的字符串。

```c++
#include <bits/stdc++.h>

using namespace std;
char s1[1005], s2[1005];

int main() {
    fgets(s1, 1004, stdin);
    fgets(s2, 1004, stdin);
    int len1 = strlen(s1) - 1;
    int len2 = strlen(s2) - 1;
    int ans = 0;
    for (int i = 0; i + len2 - 1 <= len1 - 1; i++) {
        bool matched = true;
        for (int j = 0; j <= len2 - 1; j++) {
            if (s1[i + j] != s2[j]) {
                matched = false;
                break;
            }
        }
        if (matched)ans++;
    }
    printf("%d", ans);
    return 0;
}
```

```
ossosso
osso

2
```

## 3. 日期类题型

1. 蒜头君的生日快到了，蒜头君希望是在周末，蒜头君请你帮忙算出他生日在星期几。

   **输入格式**

   输入三个正整数，分别表示年、月、日。保证输入年份合法。

   **输出格式**

   输出星期几。
   用 `Monday` 、`Tuesday` . `Wednesday` . `Thursday` `....`表示星期几。

```c++
// 一般分析方法
#include <bits/stdc++.h>

using namespace std;

string weekday[7] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

bool isLeapYear(int year) {
    return (year % 100 != 0 && year % 4 == 0) || year % 400 == 0;
}

int whatday(int y, int m, int d) {
    int ans = 0;
    for (int i = 1; i < y; i++) {
        if (isLeapYear(i)) {
            ans += 366 % 7;
            ans %= 7;
        } else {
            ans += 365 % 7;
            ans %= 7;
        }
    }
    for (int i = 1; i < m; i++) {
        if (i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10 || i == 12) {
            ans += 31 % 7;
            ans %= 7;
        } else if (i == 4 || i == 6 || i == 9 || i == 11) {
            ans += 30 % 7;
            ans %= 7;
        } else if (isLeapYear(y)) {
            ans += 29 % 7;
            ans %= 7;
        } else {
            ans += 28 % 7;
            ans %= 7;
        }
    }
    ans += (d - 1) % 7;
    ans %= 7;
    return ans;
}

int main() {
    int y, m, d;
    cin >> y >> m >> d;
    cout << weekday[whatday(y, m, d)] << endl;
    return 0;
}
```

---

除此之外，有一个公式可以快速地根据日期计算这一天是星期几，这被称为蔡基姆拉尔森计算公式。

假设星期为w，年份为y，月份为m，日期为d。
`w=(d+2×m+3×(m+1)/5+y+y/4-y/100+y/400)%7`

然后把计算出来的w加上1就是真正的星期几了。

**注意每年的1,2月要当成上一年13,14月计算，上述的除法均为整除。**

```c++
#include <bits/stdc++.h>

using namespace std;

string weekday[7] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

int whatday(int y, int m, int d) {
    if (m <= 2) {
        m += 12;
        y--;
    }
    return (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;
}

int main() {
    int y, m, d;
    cin >> y >> m >> d;
    cout << weekday[whatday(y, m, d)] << endl;
    return 0;
}
```

2. 蒜头君和花椰妹谈恋爱啦。祝福他们吧。蒜头君想知道第他们的第100天，200天....纪念日。

   **输入格式**

   输入4个整数y, m, d, k，表示他们在一起的日期，保证是一个1900年1月1日以后的日期，蒜头君想知道他们的k(0≤k ≤ 10000)天纪念日。

   **输出格式**

   输出格式按照 `yyyy-mm-dd`的格式输出k天纪念日的日期。月份和天数必须各输出2位。保证最后答案年份不超过4位。

```c++
#include <bits/stdc++.h>

using namespace std;
int day[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,};

bool isLeapyear(int year) {
    return (year % 100 != 0 && year % 4 == 0) || year % 400 == 0;
}

int main() {
    int y, m, d, k;
    scanf("%d%d%d%d", &y, &m, &d, &k);
    for (int i = 1; i <= k; i++) {
        if (isLeapyear(i)) {
            day[2] = 29;
        } else {
            day[2] = 28;
        }
        d++;
        if (d == day[m] + 1) {
            d = 1;
            m++;
        }
        if (m == 13) {
            m = 1;
            y++;
        }
    }
    printf("%04d-%02d-%02d\n", y, m, d);
    return 0;
}
```

```
//输入
2016 10 1 100
//输出
2017-01-09
```

---

## 4. 枚举

枚举

- 是根据提出的问题，——列出该问题的所有可能的解，并在逐一列出的过程中，检验每个可能解是否是问题的真正解，如果是就采纳这个解，如果不是就继续判断下一个。
- 枚举法一般比较直观，容易理解，但由于要检查所有的可能解，因此运行效率较低。
- 能够用枚举法解决的题目往往是最简单的一类题目。这种题目具有以下特点:

  - 解枚举范围是有穷的。
  - 检验条件是确定的。

枚举法的结构

- **枚举范围循环＋条件判断语句**。

1. 输入两个正整数n,m，输出n,m之间有哪些质数

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    if (n > m) {
        swap(n, m);
    }
    for (int i = n; i <= m; i++) {
        if (i == 1) {
            continue;
        }
        bool is_prime = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            cout << i << endl;
        }
    }
    return 0;
}
```

```
// 输入
2 10
// 输出
2
3
5
7
```

---

## 5. C++常用STL库

### 5.1 vector

vector是一种动态数组，他的长度可以根据我们的需求动态改变。

---

**定义一个动态数组**

语法：

- `vector<T> vec`

这样我们定义了一个名为 `vec`的存储 `T`类型数据的动态数组

---

**构造函数**

语法

```c++
int n=10;
vector<int> vec(n,1);
```

初始化 `vec`为10个长度，并赋值

---

**插入元素**

语法

- `vec.push_back()`

在 `vec`数组最后面插入一个新的元素

---

**获取长度并且访问元素**

语法

- `vec.size()`

获取 `vec`数组的长度，通过 `[]`操作符可以直接访问 `vec`元素和数组一致

---

**删除元素**

语法

- `vec.pop_back()`

删除 `vec`动态数组的最后一个元素

---

**清空**

语法

- `vec.clear()`

 清空 `vec`，但是不会清空 `vec`的内存

---

**清空内存**

```c++
vector<int>v;
vector<int>().swap(v); //通过创建空的数组，然后交换清空内存
```

---

**二维动态数组**

语法

- `vector< vector <int> > vec`

创建了一个二维动态数组 `vec`

使用构造函数，我们可以快速构造一个n行m列的动态数组

语法

- `vector<vector<int> >vec(n,vector<int>(m,0))`

构建了一个n行m列的动态数组，并赋值为0

---

### 5.2 set

set(集合)

- 集合是数学中的一个基本概念,通俗地理解,集合是由一些不重复的数据组成的。比如{1,2,3}就是一个有1,2,3三个元素的集合。
- c++中 `set`容器会自动进行从小到大的排序

---

**定义一个集合**

语法

- `set<T> s`

这样我们定义了一个名为 `s`的存储 `T`类型数据的集合

---

**插入元素**

语法

- `s.insert()`

用 `insert()`函数向集合中插入一个新的元素。**注意如果集合中已经存在了某个元素，再次插入不会产生任何效果，集合中是不会出现重复元素的。**

---

**删除元素**

语法

- `s.erase()`

用 `erase()`删除集合中的一个元素，如果集合中这个元素不存在，不进行操作

---

**判断元素是否存在**

语法

- `s.count()`

用 `count()`函数。如果集合中存在我们要查找的元素，返回1,否则返回0

---

**迭代器**

语法

- `set<T>::iterator it`

`it`为 `set` 容器的迭代器，在用法上和指针类似

`begin()`起始迭代器， `end()`尾端迭代器

---

**遍历**

使用迭代器即可遍历 `set`容器

```c++
for(set<T>::iterator it = s.begin();it!=s.end();it++){
    cout<< *it <<endl;
}
```

---

**清空**

`s.clear()`即可清空 `s`容器，同时会清空 `s`占用的空间

---

**set容器配合结构体使用**

因为set容器默认会进行排序，所以定义结构体时还需要定义比较方法，即重载小于号操作符

```c++
struct Node{
  int x,y;
  bool operator<(const Node &rhs) const{
        if(x == rhs.x){
            return y < rhs.y;
        }else {
            return x < rhs.x;
        }
    }
};
```

`operator<`表示我们要重载运算符 `<`，可以看成是一个函数名。`rhs`是 `“right hand side”`的简称，有右操作数的意思，这里我们定义为一个 `const`引用。因为该运算符重载定义在结构体内部，左操作数就当前调用 `operator<`的对象。

特别要注意，不要漏掉最后的 `const`。`const`函数表示不能对其数据成员进行修改操作，并且 `const`对象不能调非 `const`成员函数,只允许调用 `const`成员函数。

上面重载规定了排序方式为，优先按照 `x`从小到大排序，如果 `x`相同，那么再按照 `y `从小到大排序。经过了 `<`运算符重载的结构体，我们就可以比较两个 `Node`对象的大小了，因此可以直接储存在 `set`中了。

---

### 5.3 map

map(映射)

- 映射是指两个集合之间的元素的相互对应关系。通俗地说，就是一个元素对应另外一个元素。
- 这两个元素分别叫**关键字**、**值**，c++中使用 `map`容器来反映映射关系

---

**定义一个映射**

语法

- `map<T1,T2> m;`

这样我们定义了一个名为 `m`的从 `T1`类型到 `T2`类型的映射。

---

**插入一对映射**

语法

- `m.insert()`，参数是一个 `pair`类型数据

> 如果插入的 `key`之前已经存在了，将不会用插入的新的 `value` 替代原来的 `value`

---

**访问映射**

使用 `[key]`访问映射，如果没有对 `key`做过映射的话，会自动为 `key`生成一个映射，其 `value`为对应类型的默认值

当然有些时候，我们不希望系统自动为我们生成映射，这时候我们需要检测 `key`是否已经有映射了，如果已经有映射再继续访问。这时就需要用 `count()`函数进行判断。

---

**判断关键字是否存在**

语法

- `m.count(key)`

如果关键字存在，返回1，否则返回0

---

**遍历映射**

遍历映射和遍历集合类似，使用 `map<T1,T2>::iterator it`迭代器访问，其中 `first`和 `second`对应的就是映射的 `key`和 `value`

```c++
for(map<T1,T2>::iterator it = dict.begin();it!=dict.end();it++){
    cout<<it->first<<" "<<it->second<<endl; //fisrt 是关键字，second是值
}
```

---

**map套用set**

为了帮助理解，我们举用一个生活中实际例子。全校有很多班级，每个班级每个人都会有中文名。现在我们需要用一种方式来记录全校的同学的名字。如果直接用一个 `set`记录，对于重名的同学，那么就没办法分辨了。
我们可以把全校的班级进行编号，对每一个班级建立一个 `set`，也就是每个班级都映射成一个 `set`，这样就能分辨不同班级的同名同学了。对于同班的同学来说，—般很少有重名的。

`map<int，set<string> >s`就定义上面描述的数据结构，和二维 `vector`一样，两个 `>>`中间的空格不能少了。
这样我们就可以进行插入和查询了。比如对2班的 `yuhaoran`同学，我们 `s[2].insert("yuhaoran")`。然后查询 `yuhaoran`是不是一个2班的人, `s[2].count(" yuhaoran")`。然后还可以把他从2班删除，`s[2].erase("yuhaoran")`。

---

**map套用map**

上面的结构没有办法解决同班同名的情况。实际上，如果同班同名，单单通过名字本身是无法分辨的，需要通过其他特征来分辨。所以为了简单起见，我们只需要记录每个班级同名的人的个数。

这时候，我们把里面的 `set`改成 `map`即可。`map<int，map<string，int> > s`。2班有一个 `yuhaoran`，`s[2]["yuhaoran"]++`。2班又转来了一个 `yuhaoran` ,`s[2]["yuhaoran"]++`。

现在2班一共有多少个 `yuhaoran` ?

```c++
cout<<s[2]["yuhaoran"]<<endl;
```

#### 5.3.1 pair类型

`pair`是一个标准库类型，定义在头文件 `utility`中。可以看成是有两个成员变量 `first`和 `second`的结构体，并且重载了 `<`运算符（先比较 `first`大小，如果一样再比较 `second`)。当我们创建一个 `pair`时，必须提供两个类型。

定义

- `pair<T1,T2> p;`

make_pair

- `make_pair(v1,v2)`函数返回由 `v1`和 `v2`初始化的 `pair`，类型可以从 `v1`和 `v2`的类型推断出来

---

### 5.4 stack

stack(栈)

- 栈，是一种满足一定约束的线性数据结构。其约束是∶只允许在栈的一端插入或删除元素，这—端被称为**栈顶**;相对地，我们把另一端称为**栈底**。

---

**定义一个栈**

语法

- `stack<T> s`

定义了一个存储 `T`类型数据的栈 `s`

---

**压入(push)、压出(pop)**

`s.push()`压入一个元素到栈内，`s.pop()`压出一个元素

---

**获取栈顶元素**

语法

- `s.top()`

---

**判断栈是否为空**

语法

- `s.empty()`

---

**计算栈内元素个数**

语法

- `s.size()`

---

## 6. 递归

递归

- 递归是计算机编程中应用最广泛的一个技巧，也是比较难理解的一个技巧。
- 所谓递归，就是函数调用函数自身，一个函数在其定义中有直接或者间接调用自身都叫递归。而递归一般都用来解决有重复子问题的
  问题。
- 递归分为**直接递归**和**间接递归**

---

**直接递归**

使用直接递归求解 `n!`，因为 `n! = n × (n-1)!`，所以可以写下下面代码

```c++
int factorial(int n) {
    return n*factorial(n-1);
}
```

但实际上，我们计算到 `n = 1`时就停止了，而计算机不会停止，它还会一直运行下去，这样就引申出递归的一个难点--**边界条件**。

> 所谓边界条件，就是在什么情况下，函数不应该再继续调用自身了。

所以 `n!`可以写成这样

```c++
int factorial(int n) {
    if(n=1){
        return 1;
    }
    return n*factorial(n-1);
}
```

斐波那契数列

```c++
int fib(int x){
    if(x == 1 || x == 2){
        return 1;
    }
    return fib(x-1) + fib(x-2);
}
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4008f2c5f5149171ddacafce81b2c4ac.png)

汉诺塔

> 汉诺塔(又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在**小圆盘上不能放大圆盘**，在三根柱子之间**一次只能移动一个圆盘**，如图所示:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/936db35056a0316f004807494f44880d.png)

```c++
#include<bits/stdc++.h>
using namespace std;

stack<int> s[3];

void move(int x,int y) {
	int temp = s[x].top();
	s[x].pop();
	s[y].push(temp);
	cout<<x<<" "<<y<<endl;
}

void hanoi(int A,int B,int C,int n) {
	if(n==1) {
		move(A,C);
		return;
	}
	hanoi(A,C,B,n-1);
	move(A,C);
	hanoi(B,A,C,n-1);
}

int main() {
	int n;
	cin>>n;
	for(int i=n; i>=1; i--) {
		s[0].push(i);
	}
	hanoi(0,1,2,n);
	while(!s[2].empty()) {
		cout<<s[2].top()<<" ";
		s[2].pop();
	}
	return 0;
}
```

---

**递归练习**

1. 蒜头君买了一堆桃子不知道个数，第一天吃了一半的桃子，还不过瘾，又多吃了一个。以后他每天吃剩下的桃子的一半还多一个，到 `n`天只剩下一个桃子了。蒜头君想知道一开始买了多少桃子。

   **输入格式**

   输入一个整数$n(2≤n ≤30)$。

   **输出格式**

   输出买的桃子的数量。

```c++
#include<bits/stdc++.h>
using namespace std;

int n; //使用全局变量减少使用参数

int eat(int x) { // 函数内部用于增加天数的变量
	if(x==n)    // 第n天桃子数量为1
		return 1;
	return (eat(x+1)+1)*2; // 一天吃一半多一个，倒推得此式子
}

int main() {
	cin>>n;
	cout<<eat(1)<<endl;
	return 0;
}
```

```
//输入
2
//输出
4
```

```
//输入
3
//输出
10
```

---

2. 相信小伙伴们都学过斐波那契数列，它是这样的一个数列:1,1,2,3,5,8,13,21··。

   用fn表示斐波那契数列的第n项，则有:
   $f_1=f_2=1,f_n=f_{n-1}+ f_{n-2}(n > 2)$.
   为了提高难度，蒜头君决定修改公式，如下;用f,表示新数列的第n项，则有:
   $f_1= f_2= 1,f_n = af_{n-1}+bf_{n-2}(n > 2)$.

   **输入格式**

   输入每行包含4个整数

   $n(1 ≤n ≤100)$,
   $a(1 ≤a≤10)$,
   $b(1 ≤b≤10)$,
   $p(1 ≤p ≤2000)$.

   **输出格式**

   输出$f_n$对$p$取模的值

   ```c++
   #include<bits/stdc++.h>
   using namespace std;
   
   int ans[2005]; //存储答案
   bool vis[2005];//记录是否已经计算过
   
   int f(int n,int a,int b,int p) {
   	if(vis[n]) {
   		return ans[n]; // 如果已经计算过，直接返回
   	}
   	vis[n] = true;      // 将没有计算的n标记为计算过的
   	if(n==1||n==2) {
   		return ans[n] = 1 % p; // ans[n] = 1 % p;返回值还是ans[n]
   	}
   	return ans[n] = (a*f(n-1,a,b,p)%p + b*f(n-2,a,b,p)%p)%p;
   }
   
   int main() {
   
   	int n,a,b,p;
   	cin>>n>>a>>b>>p;
   	cout<<f(n,a,b,p)<<endl;
   	return 0;
   }
   ```

   ```
   // 输入
   3 1 1 1000
   //  输出
   2
   ```

   ```
   // 输入
   5 2 2 1233
   // 输出
   28
   ```

---

## 7. 深度优先搜索

**深度优先搜索**，简称dfs，是一个经典的搜索算法。我们常用递归实现深度优先搜索

使用递归实现阶乘

```c++
int fac(int n){
    if(n==1){
        return 1;
    }
    return n * fac(n-1);
}
```

使用递归实现斐波那契数列

```c++
int fib(int n){
    if( n == 1 || n == 2) {
        return 1;
    }
    return fib(n-1) + fib(n-2);
}
```

这两个案例都可以称之为深度优先搜索

深度优先搜索按照深度优先的方式进行搜索，通俗点说就是“一条路走到黑”。注意,这里的“搜索”不是指的我们平时在文件中或者在网络上查找某些信息，搜索是一种穷举的方式，把所有可行的方案都列出来，不断去尝试，直到找到问题的解。

> 深度优先搜索和递归的区别是︰深度优先搜索是一种算法，注重的是思想;而递归是一种基于编程语言的实现方式。深度优先搜索可以用递归实现，也就是说递归是我们用计算机编程语言来实现深度优先搜索这个算法的手段。

深度优先搜索也可以使用非递归的方法实现

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f74ac9b604dcfcead5576e48c20c2aa7.png)

上图是 Fib(5)的搜索过程，我们发现这个过程实际上对应着一棵树，这颗树被称为**搜索树**。

### 7.1 常见深度优先搜索

使用深度优先搜索实现迷宫游戏

**迷宫游戏**

我们用一个二维的字符数组来表示前面画出的迷宫:

```
S**.
....
***T
```

其中字符 `S`表示起点，字符 `T`表示终点，字符 `*`表示墙壁，字符 `﹒`表示平地。你需要从 `S`出发走到 `T`，每次只能向上下左右相邻的位置移动，不能走出地图，也不能穿过墙壁，每个点只能通过一次。你需要编程来求解出一种从起点到终点的走法。

迷宫问题的解法就需要用到 `dfs`。我们对上下左右四个方向，一个方向一个方向地尝试，如果沿着某个方向不能走到终点，我们就要原路返回，继续尝试其他方向，直到走出迷宫。这是一种最朴素的走迷宫方式,虽然效率也许比较低，但如果迷宫有解，就—定能走出终点。

上面说的这种走法，就对应着我们要讲的 `dfs`算法。首先找到起点s，走到每个点时按照左、下、右、上的顺序尝试。每走到下一个点以后，我们把这个点当做起点s，继续按顺序尝试。如果某个点上下左右四个方向都尝试过，便回到走到这个点之前的点，这一步我们称之为**回溯**。继续尝试其他方向。直到所有点都尝试过上下左右四个方向。

这就好比你自己去走这个迷宫，你也要一个方向一个方向的尝试着走，如果这条路不行，就回头，尝试下一条路，`dfs`的思想和我们直观的想法很类似。只不过，接下来我们需要用程序来完成这个过程。

迷宫dfs程序框架

```c++
// 对坐标为(x,y)的点进行搜索
bool dfs(int x,int y){
	if(x,y) 是终点{
		//找到终点
		return true;
	}
	标记(x,y)已经访问
	向上走到位置(tx,ty)
	if(tx,ty) 在地图里面且没有访问 {
        if(def(tx,ty) == true){
        	return true;
		}
	}
	向左走到位置(tx,ty)
	if(tx,ty) 在地图里面且没有访问 {
        if(def(tx,ty) == true){
        	return true;
		}
	}
	向下走到位置(tx,ty)
	if(tx,ty) 在地图里面且没有访问 {
        if(def(tx,ty) == true){
        	return true;
		}
	}
	向右走到位置(tx,ty)
	if(tx,ty) 在地图里面且没有访问 {
        if(def(tx,ty) == true){
        	return true;
		}
	}
	取消(x,y)访问标记
	return false;
}
```

接下来实现迷宫游戏

```c++
#include<bits/stdc++.h>
using namespace std;

int n,m;
string maze[110];       //存储坐标
bool vis[110][110];     //存储坐标是否计算过

bool in(int x,int y) {
	//判断点是否在地图内
	return x>=0 && x<n && y>=0 && y<m;
}

bool dfs(int x,int y) {
	if(maze[x][y] == 'T') {
		return true;    //到达终点结束递归，返回true
	}
	vis[x][y] = true;   //否则标记当前点，开始计算
	maze[x][y] = 'm';   //标记运动轨迹
	int tx = x - 1,ty=y; //向左走
	//撞墙判断
	if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
		if(dfs(tx,ty)) {
			return true;
		}
	}
	tx = x,ty = y - 1;  //向上走
	if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
		if(dfs(tx,ty)) {
			return true;
		}
	}
	tx = x + 1,ty = y;  //向右走
	if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
		if(dfs(tx,ty)) {
			return true;
		}
	}
	tx = x,ty = y + 1;  //向下走
	if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
		if(dfs(tx,ty)) {
			return true;
		}
	}
	//如果没找到，取消标记
	vis[x][y] = false;
	maze[x][y] = '.';
	return false;
}

int main() {
	//输入迷宫地图
	cin>>n>>m;
	for(int i=0; i<n; i++) {
		cin>>maze[i];
	}
	int x,y;
	//找到起始点坐标
	for(int i=0; i<n; i++) {
		for(int j=0; j<m; j++) {
			if(maze[i][j] == 'S') {
				x = i,y = j;
			}
		}
	}
	//如果能走出去，输出轨迹，不能则输出“NO！”
	if(dfs(x,y)) {
		for(int i=0; i<n; i++) {
			cout<<maze[i]<<endl;
		}
	} else {
		cout<<"NO!"<<endl;
	}
	return 0;
}
```

```
//输入
5 6
....S*
.**...
.*..*.
*..**.
.T....
//输出
....m*
.**.mm
.*..*m
*..**m
.Tmmmm
```

在上面的代码中，方向的判断重复代码比较多，可以使用循环遍历的方法遍历四个方向。

```c++
#include<bits/stdc++.h>
using namespace std;

int n,m;
string maze[110];       //存储坐标
bool vis[110][110];     //存储坐标是否计算过
int dir[4][2]= {{-1,0},{0,-1},{1,0},{0,1}}; //存储方向
bool in(int x,int y) {
	//判断点是否在地图内
	return x>=0 && x<n && y>=0 && y<m;
}

bool dfs(int x,int y) {
	if(maze[x][y] == 'T') {
		return true;    //到达终点结束递归，返回true
	}
	vis[x][y] = true;   //否则标记当前点，开始计算
	maze[x][y] = 'm';   //标记运动轨迹
	//撞墙判断,使用循环遍历四个方向
	for(int i=0; i<4; i++) {
		int tx = x + dir[i][0];
		int ty = y + dir[i][1];
		if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
			if(dfs(tx,ty)) {
				return true;
			}
		}
	}
	//如果没找到，取消标记
	vis[x][y] = false;
	maze[x][y] = '.';
	return false;
}

int main() {
	//输入迷宫地图
	cin>>n>>m;
	for(int i=0; i<n; i++) {
		cin>>maze[i];
	}
	int x,y;
	//找到起始点坐标
	for(int i=0; i<n; i++) {
		for(int j=0; j<m; j++) {
			if(maze[i][j] == 'S') {
				x = i,y = j;
			}
		}
	}
	//如果能走出去，输出轨迹，不能则输出“NO！”
	if(dfs(x,y)) {
		for(int i=0; i<n; i++) {
			cout<<maze[i]<<endl;
		}
	} else {
		cout<<"NO!"<<endl;
	}
	return 0;
}
```

前面我们学习的迷宫上的搜索只是在寻找是否有路径可达，现在我们想求出最少需要多少步能到达终点。

还是借助搜索，我们只需要在搜索的时候多记录一些其他信息，用一个参数来记录前面搜索已经走了多少步了。

```c++
#include<bits/stdc++.h>
using namespace std;

int n,m;
string maze[110];       //存储坐标
bool vis[110][110];     //存储坐标是否计算过
int dir[4][2]= {{-1,0},{0,-1},{1,0},{0,1}}; //存储方向
int ans = 10000000;     //设置一个绝对大的数字，用来比较步数
bool in(int x,int y) {
	//判断点是否在地图内
	return x>=0 && x<n && y>=0 && y<m;
}

void dfs(int x,int y,int step) { // 使用step来存储步数
	if(maze[x][y] == 'T'){
		if(step<ans){
			ans = step;         // 记录最小步数
		}
		return;
	}
	vis[x][y] = true;   //否则标记当前点，开始计算
	//撞墙判断,使用循环遍历四个方向
	for(int i=0; i<4; i++) {
		int tx = x + dir[i][0];
		int ty = y + dir[i][1];
		if(in(tx,ty) && maze[tx][ty] != '*' && !vis[tx][ty] ) {
			dfs(tx,ty,step+1);
		}
	}
	//如果没找到，取消标记
	vis[x][y] = false;
}

int main() {
	//输入迷宫地图
	cin>>n>>m;
	for(int i=0; i<n; i++) {
		cin>>maze[i];
	}
	int x,y;
	//找到起始点坐标
	for(int i=0; i<n; i++) {
		for(int j=0; j<m; j++) {
			if(maze[i][j] == 'S') {
				x = i,y = j;
			}
		}
	}
	dfs(x,y,0);
	cout<<ans<<endl;
	return 0;
}
```

```
//输入
5 6
....S*
.**...
.*..*.
*..**.
.T....
//输出
7
```

---

### 7.2 抽象深度优先搜索

1. 从`n`个数中选出`k`个数的和为`sum`

```c++
#include <bits/stdc++.h>
using namespace std;
int n, k, sum, ans;
int a[40];
//i: 当前处理到第几个数
//cnt: 当前已经选了几个数
//s: 当前已经选了的数的和
void dfs(int i, int cnt, int s)
{
  //当前已经选了几个数等于k并且当前已经选了的数的和等于sum
  if (i == n)
  {
    //当前已经选了几个数等于k并且当前已经选了的数的和等于sum
    if (cnt == k && s == sum)
    {
      ans++;
    }
    return;
  }
  //一个是不选当前数，一个是选当前数
  dfs(i + 1, cnt, s);
  dfs(i + 1, cnt + 1, s + a[i]);
}
int main()
{
  cin >> n >> k >> sum;
  for (int i = 0; i < n; i++)
  {
    cin >> a[i];
  }
  ans = 0;
  //0: 当前处理到第几个数
  //0: 当前已经选了几个数
  //0: 当前已经选了的数的和
  dfs(0, 0, 0);
  cout << ans << endl;
  return 0;
}
```



## 8. 广度优先搜索



## 9. 动态规划

### 9.1 入门例题

例1. 有一楼梯共$n$级，刚开始时你在第0级，若每次只能跨上一级或二级，要走上第$n$级，共有多少种走法?

- 当$n=10$时,答案为？

1. 第一级的时候有一种跨法，即一步
2. 第二级的时候有两种，即一步一步上跨两次和两步上一次完成
3. 第三级的时候考虑最后一步，最后一步跨一级原来就是两级的，最后一步跨两级，原来就是一级的
4. 第四级的时候考虑最后一步，最后一步是跨一级的原来就是三级，最后一步是两级的原来就是两级

5. 即$A_n = A_{n-1}+A_{n-2} (n\geq 3)$，就是斐波那契数列，(比如四级的时候是三级的数量加二级的数量等于5步)
6. 所以十级的时候是$89$



例2. 请问平面上$n$条彼此相交而无三者共点的直线，能够把平面分割成多少部分?

- 当$n=10$时，答案为？

1. 一条的时候是2，两条的时候是4，三条的时候是7，...
2. 即$A_n=A_{n-1}+n$，(三条的时候是两条的数量加三等于7)



例3. 设$n$封信，所有信都装错的情况为$F_n$。

所以当添加第$n$封信的时候，我们可以直接想到，这封信与前$n-1$封信中的一封放错，那么我们就有$n-1$种选择。所以我们就可以得到$F_{n-1}\times (n -1)$种情况。

这个时候仿佛已经是最后的答案了，但是我们如果仔细想的话，我们会发现我们疏漏了一种情况。因为前$n-1$封信都是错排。所以$F_{n-1}$的方案里面不会存在有一封信放在正确的位置。但是如果有一封信放在正确的位置，那么第$n$封信与他错排,依然是一种方案。这个时候就相当于$n-2$封信相互错排，前$n-1$封中的一封信和第$n$封信错排。所以我们就可以得到$F_{n-2}\times (n -1)$的方案数。

到这里，我们已经可以得出这个递推式了，根据乘法原理:$F_n= (n -1)\times (F_{n-1}+ F_{n-2})$。

我们再想一下，代码中的初始条件，也就是边界值。在只有一封信的时候，不可能装错，那么$F_1=0$;有两封信的时候，装错的方案数为$F_2=1$。这就是著名的**错排公式**。

```c++
// 实现代码
#include <iostream>
using namespace std;

const int N = 1e3 + 9;
typedef long long ll;

ll f[N];

int main()
{
	int n;
	cin >> n;
	f[1] = 0;
	f[2] = 1;
	for (int i = 3; i <= n; i++) {
		f[i] = (f[i-1] + f[i-2]) * (i-1);
	}
	cout << f[n] << endl;
  	return 0;
}
```



例4. 杨辉三角是二项式系数在三角形中的一种几何排列。它的每个数等于它上方两数之和，每行数字左右对称，由1开始逐渐变大。

```
1
1  1
1  2  1
1  3  3  1
1  4  6  4  1
1  5  10 10 5  1
```

请求出杨辉三角的第$i$行，第$j$项的数字是什么?请通过递推式表达出来。

递推式:
$$
f[i][j]=f[i-1][j-1]+f[i-1][j]
$$

```c++
// 实现代码
#include <iostream>
using namespace std;

const int N = 1e3;
typedef long long ll;

ll f[N][N];

void init () {
	for (int i = 1; i < N; i++) {
		for (int j = 1; j <= i; j++) {
			if (j == 1) {
				f[i][j] = 1;
			} else {
				f[i][j] = f[i-1][j-1] + f[i-1][j];
			}
		}
	}
}

int main() {
	init();
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			cout << f[i][j] << " ";
		}
		cout << endl;
	}
	return 0;
}
```



例5. 

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b3dcf251869e6fd9944c974f23e7f6f8.png)

$A$点有一个过河卒，需要走到目标$B$点。

卒行走规则:可以向下、或者向右。同时在棋盘上的任一点有一个对方的马(如上图的$C$点)，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图$C$点上的马可以控制$9$个点(图中的$P1$, $P2$..$P8$和$C$)。卒不能通过对方马的控制点。

棋盘用坐标表示，$A$点$(0,0)$、$B$点$(n, m)$、$C$点($c_x,c_y)$ $(0<C_x<n≤20,0<C_y<m≤20)$。现在要求你计算出过河卒从$A$点能够到达$B$点的路径的条数。注:象棋中马走“日”。

根据题目的要求，卒只能向下或者向右走，那么想要到达棋盘上的一个点，有两种方式︰从左边的格子过来，或者从上边的格子过来。所以，过河卒到达某点的路径数目等于**到达与其相邻的左边点和上边点的路径数目和**。我们用$F_{(i,j)}$ 来表示到达点$(i,j)$的路径数目。
所以递推式为:$F_{(i,j)}=F_{(i-1,j)}+F_{(i,j-1)}$。我们根据递推式发现,我们可以用逐行或逐列的递推方法求出从起点到终点的路径数目。

我们来想一下边界条件，因为$(0,0)$是卒的起始位置，那么$F_{(0,0)}= 1$。我们在不考虑马控制点的情况下，可以写出递推代码。

```c
f[0][0] = 1;
for (int i = 0; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
        if (i != 0) {
            f[i][j] = f[i][j] + f[i-1][j];
        }
        if (j != 0) {
            f[i][j] = f[i][j] + f[i][j-1];
        }
    }
}
// f[n][m]即为从(0,0)到(n,m)的路径数目
```

我们再想一下如何处理马控制的点。马控制的点的路径数一定是0，这样其实并不影响我们做递推只要遇到了马控制的点，直接设置为0就可以了。所以，我们**需要提前标记出哪些点是马控制的点**。我们可以用两个一维数组来表示马的横向位移和纵向位移，这样来方便我们计算马的控制点，然后使用一个二维数组来标记某个点是否是马控制的点。

```c
int cx, cy; // 马的坐标
int x[8] = {1,1,2,2,-1,-1,-2,-2}; // 横向坐标
int y[8] = {2,-2,1,-1,2,-2,1,-1}; // 纵向坐标
int d[30][30]; // 用来记录是否是马控制点
for (int i = 0; i < 30; i++) {
	for (int j = 0; j < 30; j++) {
		d[i][j] = 0;
	}
}
d[cx][cy] = 1; // 用 1 来表示该点为马控制点
for (int i = 0; i< 8; i++) {
	int tx = cx + x[i]; // 计算马控制点横坐标
	int ty = cy + y[i]; // 计算马控制点纵坐标
	if (tx >= 0 && tx <= n && ty >= 0 && ty <= n) {
		d[tx][ty] = 1; // 记录为马控制点
	}
}
```



### 9.2 动态规划入门

动态规划是编程解题的一种重要手段。1951年美国数学家R.Bellman等人，根据一类多阶段问题的特点，把多阶段决策问题变换为一系列互相联系的单阶段问题，然后逐个加以解决。与此同时，他提出了解决这类问题的“最优化原理”，从而创建了解决最优化问题的一种新方法:**动态规划**。

> 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。



#### 9.2.1 动态规划的基本概念

- **阶段**: 把所给问题的求解过程恰当地分成若干个相互联系的阶段，以便于求解。过程不同，阶段数就可能不同。描述阶段的变量称为阶段变量，常用$k$表示。阶段的划分，一般是根据时间和空间的自然特征来划分，但要便于把问题的过程转化为多阶段决策的过程。
- **状态**: 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。通常一个阶段有若干个状态，状态通常可以用一个或一组数来描述，称为状态变量。
- **决策**: 表示当过程处于某一阶段的某个状态时，可以做出不同的决定，从而确定下一阶段的状态，这种决定称
  为决策。不同的决策对应着不同的数值，描述决策的变量称决策变量。
- **状态转移方程**: 动态规划中本阶段的状态往往是上一阶段的状态和上一阶段的决策的结果，由第i段的状态$f(i)$ ,和决策$u(i)$来确定第$i+1$段的状态。状态转移表示为$F(i+1)=T(f(i),u(i))$，称为状态转移方程。
- **策略**: 各个阶段决策确定后，整个问题的决策序列就构成了一个策略，对每个实际问题，可供选择的策略有定范围，称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。



#### 9.2.2 例题

1. 蒜头君要回家，已知蒜头君在左下角$(1,1)$位置，家在右上角$(n,n)$坐标处。蒜头君走上一个格子$(i,j)$会花费一定的体力$a_{ij}$，而且蒜头君只会往家的方向走，也就是只能往上，或者往右走。蒜头君想知道他回到家需要花费的最少体力是多少。

例如下图所示，格子中的数字代表走上该格子花费的体力:

<img src="https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/19d87d341e69f49f4818f17ba23d1681.png" alt="" style="zoom:50%;" />

对于该图来说，最优策略已在图上标出，最少花费体力为∶3＋2＋4＋3 = 12。
我们把走到一个点看做一个状态，对蒜头君来说，走到一个点只有两种方式，一个是从下面走到该点，一种是从左边走到该点。那么点$(i,j)$要么是从$(i-1,j)$走到$(i,j)$，要么是从点$(i,j-1)$走到$(i,j)$。
所以从哪个点走到$(i,j)$就是一个决策。接下来，我们用$dp(i,j)$来代表走到点$(i,j)$一共花费的最少体力。
我们需要花费最少力气走到家，所以可以得到状态转移方程: $dp(i,j)= min(dp(i- 1,j), dp(i,j-1))+ a_{ij}$。根据转移方程，我们可以推出走到每个点花费的最少体力。

对于图中的边界点，要在转移前加上判断是否为边界，如: 点(1,3)只能从点(1,2)走过来，点(3,1)只能从点(2,1)走过来等等。

动态规划的题目的核心是写出状态转移方程，对于一个动态规划的题目，如果我们能写出转移方程那么代码实现就变得简单多了。大部分的动态规划题目，在计算出转移方程后，可以用类似于递推的循环结构，来写出代码。

```c++
int a[100][100]; // a数组代表在点(i,j)花费的体力
int dp[100][100]; // dp数组代表走到点(i,j)一共花费的最少体力
dp[1][1] = 0;
for (int i=1; i <= n; i++) {
    for (int j=1; j <= n; j++) {
        if (i==1 && j==1) {
            continue;
        } else if (i ==1 ){ // 边界
            dp[i][j] = dp[i][j-1] + a[i][j];
        } else if (j == 1) { // 边界
             dp[i][j] = dp[i-1][j] + a[i][j];
        } else {
            // 状态转移方程
            dp[i][j] = min(dp[i-1][j]),dp[i][j-1]) + a[i][j];
        }
    }
}
```

完整代码

```c++
#include <bits/stdc++.h>
using namespace std;
int a[100][100];
int dp[100][100]; // 这里存储的是每一步的最小体力方案
int main () {
	int n;
	cin >> n;
	for (int i=1; i <= n; i++) {
		for (int j=1; j<= n; j++) {
			cin >> a[i][j];
		}
	}
	dp[1][1] = 0;
	for (int i=1; i <= n; i++) {
		for (int j=1; j<=n; j++) {
			if (i == 1 && j == 1) {
				continue;
			} else if (i == 1) { // 边界，第一行的时候只能从下面来
				dp[i][j] = dp[i][j-1] + a[i][j];
			} else if (j == 1) { // 边界，第一列的时候只能从下面来
				dp[i][j] = dp[i-1][j] + a[i][j];
			} else {
				// 状态转移方程
				dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + a[i][j];
			}
		}
	}
	cout << dp[n][n] << endl;
	return 0;
}
```



2. 蒜头君在玩一款游戏，他在一个山顶,现在他要下山，山上有许多水果，蒜头君每下一个高度就可以捡起一个水果,并且获得水果的能量。山的形状如图所示:

```
     3
    1 2
   6 2 3
  3 5 4 1
```

这是一个高度为4的山,数字代表水果的能量。每次下一个高度，蒜头君需要选择是往左下走，还是往右下走。例如:对于上图的情况，蒜头君能获得的最大能量为，3＋1＋6＋5 = 15。现在，蒜头君希望你能帮他计算出下山能获得的最大能量。

先转换为二维数组形式

```
3
1 2
6 2 3
3 5 4 1
```

每一个点只能往它的下方或者右下方去，所以

**状态转移方程**
$$
f[i][j]=f[i][j]+max(f[i-1][j],f[i-1][j-1])
$$

```c
int f[1000][1000];
int n;
int ma = -inf;
for (int i=1; i<=n; i++) {
    for (int j=1; j<=i; j++) {
        if (i == n) { // 最后一行
            ma = max(f[i][j],ma);
        }
        f[i][j] = f[i][j] + max(f[i-1][j],f[i-1][j-1]);
    }
}
cout << ma << endl;
```

完整代码

```c++
#include <bits/stdc++.h>
using namespace std;
int f[100][100];
int main () {
	int n;
	cin >> n;
	for (int i=1; i <= n; i++) {
		for (int j=1; j<= i; j++) {
			cin >> f[i][j];
		}
	}
	int ma = -INT_MAX;
	for (int i=1; i<=n; i++) {
		for (int j=1; j<=i; j++) {
			f[i][j] += max(f[i-1][j],f[i-1][j-1]);
			if (i == n) { // 最后一行
				ma = max(f[i][j],ma);
			}
		}
	}
	cout << ma << endl;
	return 0;
}
```

```
// 输入
4
3
1 2
6 2 3
3 5 4 1
// 输出
15
```



#### 9.2.3  多维

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4df5ac6b9760411ee72b08be836a360a.png)

这个时候我们无法像第一次二维那样直接画图找规律了（当然聪明的同学可能依然能画出，但四维，五维呢? ）。这个时候我们就需要来推理了思考了。
我们用$f[i][j][k]$来表示蒜头君当前所在位置，我们可以知道蒜头君是一步到达这个位置的。我们可以知道蒜头君每次移动只会更改$i$,$j$,$k$的一个值。这个时候我们就可以知道当前位置会来自$f[i-1][i][k]$,$f[i][j-1][k]$,$f[i][j][k -1]$这三个位置。
所以我们我们只需要找到前三个状态的最小值，然后在加上当前位置消耗的体力值。就是蒜头君到达当前位置需要消耗体力的最小值。
最终我们可以得到下面的递推式:
$$
f[i][j][k]= min(f[i-1][j][k],f[i][j-1][k],f[i][j][k-1])+f[i][i][k-1]
$$

```c
for (int i=0; i<=x; i++) {
    for (int j=0;j<=y;j++) {
        for (int k=0; k<=z; k++) {
            int mi = -INT_MAX;
            if (i != 0) {
                mi = min(mi,f[i-1][j][k]);
            }
            if (j != 0) {
                mi = min(mi ,f[i][j-1][k]);
            }
            if (k !=0) {
                mi = min(mi,f[i][k][k-1]);
            }
            if (mi != -INT_MAX) {
                f[i][j][k] += mi;
            }
        }
    }
}
cout << f[x][y][z] << endl;
```

