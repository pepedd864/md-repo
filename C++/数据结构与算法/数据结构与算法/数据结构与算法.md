## 1. 简介

### 1.1 数据结构简介

​		**数据结构**是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

### 1.2 数据结构分类

传统上，我们可以把数据结构分为逻辑结构和物理结构两大类。

**逻辑结构分类:**
		逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类有下面几种。

- **集合结构:**集合结构中数据元素除了**属于同一个集合**外，他们之间没有任何其他的关系。

- **线性结构:**线性结构中的数据元素之间存在**一对一**的关系
- **树形结构:**树形结构中的数据元素之间存在**—对多**的层次关系

- **图形结构:**图形结构的数据元素是**多对多**的关系

**物理结构分类:**
		逻辑结构在计算机中真正的表示方式(又称为映像)称为物理结构，也可以叫做存储结构。常见的物理结构有**顺序存储结构**、**链式存储结构**。

**顺序存储结构:**
		把数据元素放到地址**连续的存储单元**里面，其数据间的**逻辑关系和物理关系是一致**的，比如我们常用的数组就是顺序存储结构。

​		顺序存储结构存在一定的弊端，就像生活中排时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中此时就需要链式存储结构。

**链式存储结构:**
		是把数据元素存放在**任意的存储单元**里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并**不能反映元素间的逻辑关系**，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

### 1.3 算法简介

​		**算法**是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着**用系统的方法解决问题的策略机制**。也就是说，能够对—定规范的输入，在有限时间内获得所要求的输出。

​		在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算法追求以下两个目标∶

- 花最少的时间完成需求;
- 占用最少的内存空间完成需求;

## 2. 算法分析

### 2.1 时间复杂度分析

**分析方法:**

**事后分析估算方法:**
		比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷∶必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。

**事前分析估算方法:**
		在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机上运行所消耗的时间取决于下列因素:

1. 算法采用的策略和方案;
2. 编译产生的代码质量;
3. 问题的输入规模(所谓的问题输入规模就是输入量的多少);
4. 机器执行指令的速度;

​		由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

​		我们研究算法复杂度，侧重的是**当输入规模不断增大时，算法的增长量的一个抽象(规律)**，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。

​		我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把**核心操作的次数和输入规模关联起来**。

**比较算法随输入规模的增长量时，可以有以下规则:**

1. 算法函数中的常数可以忽略;
2. 算法函数中最高次幂的常数因子可以忽略;
3. 算法函数中最高次幂越小，算法效率越高。

### 2.2 大O记法

​		在进行算法分析时，语句总的执行次数T(n)关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。
​		算法的时间复杂度，就是算法的时间量度，记作:`T(n)=O(f(n))`。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。

​		在这里，我们需要明确一个事情:**执行次数 = 执行时间**
用大写O()来体现算法时间复杂度的记法，我们称之为**大O记法**。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

**推导大O阶的表示法有以下几个规则可以使用:**

1. 用常数1**取代运行时间中的所有加法常数**;
2. 在修改后的运行次数中，只**保留高阶项**;
3. 如果最高阶项存在，且常数因子不为1，则**去除与这个项相乘的常数**;

### 2.3 常见的大O阶

#### 2.3.1 线性阶

一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    sum += i;
}
cout<<"sum="<<sum<<endl;
```

时间复杂度为O(n)

#### 2.3.2 平方阶

一般嵌套循环属于这种时间复杂度

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    for(int j = 1;j <= n; j++)
    {
        sum += i;
    }
}
cout<<"sum="<<sum<<endl;
```

时间复杂度O(n^2)

#### 2.3.3 立方阶

一般三层嵌套循环属于这种时间复杂度

```c++
int sum = 0;
int n = 100;
for (int i = 1;i <= n; i++)
{
    for(int j = 1;j <= n; j++)
    {
       for(int j = i;j <= n; j++)
       {
           sum += i;
       }
    }
}
cout<<"sum="<<sum<<endl;
```

时间复杂度O(n^3)

#### 2.3.4 对数阶

```c++
int i = 1,n = 100;
while(i<n)
{
    i = i*2;
}
```

由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n

时间复杂度O(log n)

#### 2.3.5 常数阶

```c++
int n = 100;
int i = n+2;
cout<<i<<endl;
```

上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以时间复杂度为O(1)

#### 2.3.6 总结

**常见的大O阶:**

| 描述         | 增长的数量级 | 说明     | 举例           |
| ------------ | ------------ | -------- | -------------- |
| 常数级别     | 1            | 普通语句 | 将两个教相加   |
| 对数级别     | logN         | 二分策略 | 二分查找       |
| 线性级别     | N            | 循环     | 找出最大元素   |
| 线型对数级别 | NlogN        | 分治思想 | 归并排序       |
| 平方级别     | N^2          | 双层循环 | 检查所有元素对 |
| 立方级别     | N^3          | 三层循环 | 检查所有三元组 |
| 指数级别     | 2^N          | 穷举查找 | 检查所有子集   |

**复杂度高低**

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3)

### 2.4 最坏情况

```c++
int search(int num)
{
    int arr[10]={11,10,8,9,7,22,23,0};
	for(int i = 0;i<10;i++)
	{
    	if(num == arr[i])
    	{
        	return i;
		}
	}
    return -1;
}
```

**最好情况:**
查找的第一个数字就是期望的数字,那么算法的时间复杂度为O(1)

**最坏情况:**
查找的最后一个数字,才是期望的数字，那么算法的时间复杂度为O(n)

**平均情况:**
任何数字查找的平均成本是O(n/2)

## 3. 简单排序

### 3.1 冒泡排序

冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法。

**排序原理:**

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。

**代码实现:**

```c++
vector<int> bubble_sort(vector<int> a, int n)
{
    /**
     * @brief 冒泡排序
     * 
     */
    for (int i = n - 1; i > 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            if (a[j] > a[j + 1])
            {
                swap(a[j], a[j + 1]);
            }
        }
    }
    return a;
}
```

### 3.2 选择排序

选择排序(select sort)是—种更加简单直观的排序方法。

**排序原理:**

1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值

**代码实现:**

```c++
vector<int> select_sort(vector<int> a, int n)
{
    /**
     * @brief 选择排序
     * 
     */
    for (int i = 0; i < n-2; i++)
    {
        int min = i;
        for (int j = i + 1; j < n; j++)
        {
            if (a[j] < a[min])
                min = j;
        }
        swap(a[i], a[min]);
    } 
    return a;
}
```

### 3.3 插入排序

插入排序（insert sort )是一种简单直观且稳定的排序算法。

**排序原理:**

1. 把所有的元素分为两组，已经排序的和未排序的;
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入;
3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位;

**代码实现:**

```c++
vector<int> inert_sort(vector<int> a, int n)
{
    /**
     * @brief 插入排序
     * 
     */
    for (int i = 1; i < n; i++)
    {
        for (int j = i; j > 0; j--)
        {
            if (a[j] < a[j - 1])
                swap(a[j], a[j - 1]);
            else
                break;
        }
    }
    return a;
}
```

## 4. 高级排序

### 4.1 希尔排序

希尔排序(shell sort)是插入排序的一种，又称"缩小增量排序”，是插入排序算法的一种更高效的改进版本。

**排序原理:**

1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组;
2. 对分好组的每一组数据完成插入排序;
3. 减小增长量，最小减为1，重复第二步操作。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bc98fc3f08a22bc22e7580dccdb7ab46.png)

**增长量h的确定:** 

```c++
int h=1
while(h<数组的长度/2){
	h=2h+1 ;
}
//不结束后我们就可以确定h的最大值;
h的减小规则为:
	h=h/2
```

**代码实现:**

```c++
vector<int> shell_sort(vector<int> a, int n)
{
    /**
    * @brief 希尔排序
    * 
    */
    int h = 1;
    while (h < n / 2)
        h = 2 * h + 1;
    while (h >= 1)
    {
        for (int i = h; i < n; i++)
        {
            for (int j = i; j >= h; j -= h)
            {
                if (a[j - h] > a[j])
                    swap(a[j - h], a[j]);
                else
                    break;
            }
        }
        h = h / 2;
    }
    return a;
}
```

### 4.2 并归排序

#### 4.2.1 递归

**定义:**
		定义方法时，在方法内部调用方法本身，称之为递归.

```c++
void fun()
{
    cout << "hello world" << endl;
    fun();
}
```

**作用:**
		它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。

**注意事项:**
		在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每
一次递归调用都会在栈内存开辟新的空间，重新执行方法，**如果递归的层级太深，很容易造成栈内存溢出**。

```c++
//求n的阶乘
int fac(int n)
{
    if (n == 1)
        return 1;
    return n * fac(n - 1);
}
```

#### 4.2.2 并归排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用**分治法**的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

**排序原理:**

1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。

2. 将相邻的两个子组进行合并成一个有序的大组;
3. 不断的重复步骤2，直到最终只有一个组为止。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8ffc07c9168381399f8038f543be9cf0.png)

### 4.3 快速排序

**快速排序**是冒泡排序的进阶版本，在冒泡排序中，进行元素的比较和交换是在相邻元素之间进行的，元素每次交换只能移动一个位置，所以比较次数和移动次数较多，效率相对较低。而在快速排序中，元素的比较和父换是从网端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，就像它的名字一样，速度更快。

设数组长度为N，详细过程为:

- 在一开始，排序范围是整个数组
- 排序之前，我们选择整个排序范围内的**第一个元素**作为**基准**，对排序范围内的元素进行快速排序
- 先从最右边向左看，依次将每一个元素与**基准元素**进行比较，如果发现比基准元素小，那么就与左边遍历位置上的元素（一开始是基准元素的位置)进行交换，此时保留右边当前遍历的位置。
- 交换后，转为从左往右开始遍历元素，如果发现比基准元素大，那么就与之前保留的右边遍历的位置上的元素进行交换，同样保留左边当前的位置，循环执行上一个步骤。
- 当左右遍历撞到一起时，本轮快速排序完成，最后在最中间的位置就是基准元素的位置了。
- 以基准位置为中心，划分左右两边，以同样的方式执行快速排序。

比如下面的数组:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5462c526b3e5da4e7063a45798ed9bc2.png)

首先我们选择第一个元素4作为基准元素，一开始左右指针位于两端:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e0ccbac22882cff0c029f149e89c196a.png)

此时从右往左开始看，直到遇到一个比4小的元素，首先是6，肯定不是，将指针往后移动:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1b8811a86ec960582fc6b83963c6fe0c.png)

此时继续让3和4进行比较，发现比4小，那么此时直接将3交换（其实直接覆盖过去就行了）到左边指针所指向的元素位置:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fcc5fef36f7b121078b08ed0d9435688.png)

此时我们转为从左往右看，如果遇到比4大的元素，就交换到右边指针处，3肯定不是了，因为刚刚才缓过来，接着就是2:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f7782956aa69753e1ea87c3666f1117b.png)

2也没有4大，所以说继续往后看，此时7比4要大，那么继续交换:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/09472da5a6f6370381532e8eefa74352.png)

接着，又开始从右往左看:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ce39a5d71e121ffef4150c7d8fc2d1f6.png)

此时5是比4要大的，继续向前，发现1比4要小，所以说继续交换:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2da63f8d669fc06ed8fb9e7d2e319de2.png)

接着又转为从左往右看，此时两个指针撞到一起了，排序结束，最后两个指针所指向的位置就是给基准元素的位置了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/47d61472b6e162d9f7bf48c2600312cc.png)

本轮快速排序结束后，左边不一定都是有序的，但是一定比基准元素小，右边一定比基准元素大。接着我们以基准为中心，分成两个部分再次进行快速排序:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/de78c61de1d74890a8c178d204338772.png)

这样，我们最后就可以使得整个数组有序了，当然快速排序还有其他的说法，有些是左右都找到了再交换，我们这里的是只要找到就丢过去。既然现在思路已经清楚了，我们就来尝试实现一下快速排序吧:

```c++
void quickSort(int arr[], int start, int end) {
    if (start >= end) return;
    int left = start, right = end, pivot = arr[left];
    while (left < right) {
        while (left < right && arr[right] >= pivot) right--;
        arr[left] = arr[right];
        while (left < right && arr[left] <= pivot) left++;
        arr[right] = arr[left];
    }
    arr[left] = pivot;
    quickSort(arr, start, left - 1);
    quickSort(arr, left + 1, end);
}

int main() {
    int arr[] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};
    quickSort(arr, 0, 9);
    for (auto x: arr) {
        printf("%d", x);
    }
    return 0;
}
```

这样，我们就实现了快速排序。我们还是来分析一下快速排序的稳定性，快速排序是只要遇到比基准小或者大的元素就直接交换，比如原数组就是2,2,1，此时第一个元素作为基准，首先右边1会被丢过来，变成:1,2,1，然后从左往右，因为只有遇到比基准2更大的元素才会换，所以说最后基准会被放到最后一个位置: 1,2,2，此时原本应该在前面的2就跑到后面去了，所以说快速排序算法，是一种**不稳定的**排序算法。

### 4.4 堆排序

对于一棵完全二叉树，树中父亲结点都比孩子结点小的我们称为**小根堆**（小顶堆），树中父亲结点都比孩子结点大则是**大根堆**

我们通过构建一个堆，就可以将一个无序的数组依次输入，最后存放的序列是一个按顺序排放的序列，**利用这种性质，我们可以很轻松地利用堆进行排序**，我们先来写一个小顶堆:

```c++
typedef int T;
typedef struct minHeap {
    T *data;
    int size;
    int capacity;
} *Heap;

bool initHeap(Heap heap) {
    heap->size = 0;
    heap->capacity = 11;
    heap->data = static_cast<T *>(malloc(sizeof(T) * heap->capacity));
    return heap->data != NULL;
}

bool insert(Heap heap, T e) {
    if (heap->size >= heap->capacity) return false;
    int index = ++heap->size;
    while (index > 1 && e < heap->data[index / 2]) {
        heap->data[index] = heap->data[index / 2];
        index /= 2;
    }
    heap->data[index] = e;
    return true;
}

T del(Heap heap) {
    T max = heap->data[1], e = heap->data[heap->size--];
    int index = 1;
    while (index * 2 <= heap->size) {
        int child = index * 2;
        if (child < heap->size && heap->data[child] > heap->data[child + 1]) {
            child++;
        }
        if (e <= heap->data[child]) break;
        else heap->data[index] = heap->data[child];
        index = child;
    }
    heap->data[index] = e;
    return max;
}
```

接着我们只需要将这些元素挨个插入到堆中，然后再挨个拿出来，得到的就是一个有序的顺序了:

```c++
int main() {
    int arr[] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};
    struct minHeap heap;
    initHeap(&heap);
    for (int i = 0; i < 10; i++) {
        insert(&heap, arr[i]);
    }
    for (int i = 0; i < 10; i++) {
        arr[i] = del(&heap);
    }
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}
```

虽然这样用起来比较简单，但是需要额外O(n)的空间来作为堆，所以我们可以对其进行进一步的优化，减少其空间上的占用。那么怎么进行优化呢，我们不妨换个思路，直接对给定的数组进行堆的构建。
设数组长度为N，详细过程为:

- 首先将给定的数组调整为一个大顶堆
- 进行N轮选择，每次都选择大顶堆顶端的元素从数组末尾开始向前存放(交换堆顶和堆的最后一个元素)
- 交换完成后，重新对堆的根结点进行调整，使其继续满足大顶堆的性质，然后重复上述操作。
- 当N轮结束后，得到的就是从小到大排列的数组了。

我们先将给定数组变成一棵完全二叉树，以下面数组为例:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b7896f6e37c0d3b1007dbd12c49c54c1.png)

此时，这棵二叉树还并不是堆，我们的首要目标是将其变成一个大顶堆。那么怎么将这棵二叉树变成一个大顶堆呢?我们只需要从最后一个非叶子结点（从上往下的顺序）开始进行调整即可，比如此时1是最后一个非叶子结点
所以说就从1开始，我们需要进行比较，如果其孩子结点大于它，那么需要将最大的那个孩子交换上来，此时其孩子结点6大于1，所以说需要交换:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ab173af68de5fbf2ed66a8b6d411a13c.png)

接着我们来看倒数第二个非叶子结点，也就是7，那么此时两个孩子都是小于它的，所以说不需要做任何调整，我们接着来看倒数第三个非叶子结点2，此时2的两个孩子6、8都大于2，那么我们选择两个孩子里面一个最大的交换上去:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1ede146a7b8205288e2e1d425b87f85f.png)

最后就剩下根结点这一个非叶子结点了，此时我们4的左右孩子都大于4，那么依然需要进行调整:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6e9702f1df9e0ef96724bbc82103f387.png)

在调整之后，还没有结束，因为此时4换下去之后依然不满足大顶堆的性质，此时4的左孩子大于4，我们还需要继续向下看:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/35d8b3a91fe1d3bf94e2e8b34b4230db.png)

交换之后，此时整个二叉树就满足大顶堆的性质了，我们第一次初始调整也就完成了。

此时开始第二步，我们需要一个一个地将堆顶元素往后面进行交换，相当于每次都去取一个最大的出来，直到取完，首先交换堆顶元素和最后一个元素:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d8c4f60cc69f4609adfbaa91d839a1c1.png)

此时整个数组中最大的元素已经排到对应的位置上了，然后我们不再考虑最后一个元素，此时将前面的剩余元素继续看做一棵完全二叉树，对根结点重新进行一次堆化（只需要调整根结点即可，因为其他非叶子结点的没有变动），使得其继续满足大顶堆的性质:![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b8128d343e35b5b3ae5e451d15207388.png)



继续调整

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8782e80542795802d990be56a7c65a58.png)

此时第一轮结束，接着第二轮，重复上述操作，首先依然是将堆顶元素丢到倒数第二个位置上，相当于将倒数第二大的元素放到对应的位置上去:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bc59cedd4bb41a62be12631427dc1689.png)

此时已经有两个元素排好序了，同样的，我们继续将剩余元素看做一个完全二叉树，继续对根结点进行堆化操作，使得其继续满足大顶堆性质:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3a17ce8547a435a0ff84da9250dbbfbf.png)

第三轮同样的思路，将最大的交换到后面去:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fe8e8bbe4debd59f0165bf64a0aaf78d.png)



通过N轮排序，最后每一个元素都可以排到对应的位置上了，根据上面的思路，我们来尝试编写一下代码:

```c++
void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void makeHeap(int arr[], int start, int end) {
    while (start * 2 + 1 <= end) {
        int child = start * 2 + 1; // 左子树 start*2+1 右子树 start*2+2
        if (child + 1 <= end && arr[child] < arr[child + 1]) { // 存在右孩子，且右孩子比左孩子大
            child++;
        }
        if (arr[child] > arr[start]) { // 如果上面选出来的孩子比父节点大，那么就交换
            swap(&arr[child], &arr[start]);
        }
        start = child;
    }
}

void heapSort(int arr[], int size) {
    for (int i = size / 2 - 1; i >= 0; i--) { // 对所有非叶子节点进行堆化
        makeHeap(arr, i, size - 1);
    }
    for (int i = size - 1; i > 0; i--) { // 把堆顶元素搬到后面
        swap(&arr[0], &arr[i]); // 实际上就是和倒数第i个元素交换
        makeHeap(arr, 0, i - 1); // 堆底元素被交换到堆顶，重新堆化
    }
}
```

最后我们来分析一下堆排序的稳定性，实际上堆排序本身也是在进行选择，每次都会选择堆顶元素放到后面,只不过堆是一直在动态维护的。实际上从堆顶取出元素时，都会与下面的叶子进行交换，有可能会出现:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5d65136ae174c5ed0694a1109f58c2e0.png)

所以说堆排序是**不稳定**的排序算法。

### 4.5 总结

最后我们还是来总结一下上面的三种排序算法的相关性质:

| 排序算法 | 最好情况     | 最坏情况   | 空间复杂度 | 稳定性 |
| -------- | ------------ | ---------- | ---------- | ------ |
| 快速排序 | $O(nlogn)$   | $O(n^2)$   | $O(logn)$  | 不稳定 |
| 希尔排序 | $O(n^{1.3})$ | $O(n^2)$   | $O(1)$     | 不稳定 |
| 堆排序   | $O(nlogn)$   | $O(nlogn)$ | $o(1)$     | 不稳定 |



## 5. 线性表

**线性表**是由同一类型的数据元素构成的有序序列的线性结构。

线性表中元素的个数就是线性表的长度，表的起始位置称为**表头**，表的结束位置称为**表尾**，当一个线性表中没有元素时，称为**空表**。



线性表一般需要包含以下功能:

- **初始化线性表**:将一个线性表进行初始化，得到一个全新的线性表。
- **获取指定位置上的元素**:直接获取线性表指定位置i上的元素。
- **获取元素的位置**:获取某个元素在线性表上的位置i。
- **插入元素**:在指定位置i上插入一个元素。
- **删除元素**:删除指定位置i上的一个元素。
- **获取长度**:返回线性表的长度。

实现线性表的结构一般有两种

- 一种是顺序存储实现
- 一种是链式存储实现

### 5.1 循序表

基于数组，为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为**顺序表**。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b047e45795f89b2bbcf15c0134e6021d.png)

#### 5.1.1 创建顺序表

1. 这里我们可以先定义一个新的结构体类型，将一些需要用到的数据保存在一起，这里我们以`int`类型的线性表为例:

```c
typedef struct List {
    Data *array;     // 实现循序表的底层数组
    int capacity;       // 表示底层数组的容量
    int size;          // 表中的元素数量
} List;
```

2. 编写初始化操作

```c
_Bool init(List *list) {
    list->array = (int *) malloc(sizeof(Data) * 10);    // 申请10个元素的空间
    if (list->array == NULL) {                // 申请失败
        return 0;   
    }
    list->capacity = 10;        // 容量为10
    list->size = 0;         // 元素数量为0
    return 1;
}
```

#### 5.1.2 编写插入的操作

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/243991b6d6237e2fa0132a2041bd40ca.png)

```c
_Bool insert(List *list, Data e, int index) {
    if (index < 0 || index > list->size) {    // 如果插入位置不合法
        return 0;
    }
    list->size++;        // 元素数量加1
    if (list->size > list->capacity) {  // 如果元素数量大于容量
        list->capacity *= 2;       // 容量翻倍
        list->array = (int *) realloc(list->array, sizeof(Data) * list->capacity);  // 重新申请空间
    }
    for (int i = list->size-1; i > index; i--) {
        list->array[i] = list->array[i - 1];
    }
    list->array[index] = e;
    return 1;
}
```

测试插入功能

```c
void print(List *list) {
    for (int i = 0; i < list->size; i++) {
        printf("%d\n", list->array[i]);
    }
    printf("\n");
}

int main() {
    List list;
    init(&list);
    insert(&list, 1, 0);
    insert(&list, 2, 0);
    insert(&list, 3, 0);
    insert(&list, 4, 0);
    insert(&list, 5, 0);
    insert(&list, 6, 0);
    print(&list);
    printf("capacity: %d size: %d\n", list.capacity, list.size);
    return 0;
}
```

输出

```
6
5
4
3
2
1

capacity: 10 size: 6
```

#### 5.1.3 编写删除的操作

```c
_Bool delete(List *list, int index) {
    if (index < 0 || index >= list->size) {
        return 0;
    }
    if (list->size < list->capacity / 4) {      // 如果元素数量小于容量的1/4,则容量减半
        list->capacity /= 2;
        list->array = (int *) realloc(list->array, sizeof(Data) * list->capacity);
    }
    for (int i = index; i < list->size - 1; i++) {
        list->array[i] = list->array[i + 1];
    }
    list->size--;
    return 1;
}
```

测试功能

```c
int main() {
    List list;
    srand((unsigned) time(NULL));
    init(&list);
    for (int i = 0; i < 70; ++i) {
        insert(&list, i + 1, i);
    }
    print(&list);
    printf("capacity: %d size: %d\n\n", list.capacity, list.size);
    for (int i = 0; i < 60; ++i) {
        delete(&list, rand() % 50);    // 随机删除
    }
    print(&list);
    printf("capacity: %d size: %d\n\n", list.capacity, list.size);
    return 0;
}
```

输出

```
i: 0 e: 1 i: 1 e: 2 i: 2 e: 3 i: 3 e: 4 i: 4 e: 5
i: 5 e: 6 i: 6 e: 7 i: 7 e: 8 i: 8 e: 9 i: 9 e: 10
i: 10 e: 11 i: 11 e: 12 i: 12 e: 13 i: 13 e: 14 i: 14 e: 15
i: 15 e: 16 i: 16 e: 17 i: 17 e: 18 i: 18 e: 19 i: 19 e: 20
i: 20 e: 21 i: 21 e: 22 i: 22 e: 23 i: 23 e: 24 i: 24 e: 25
i: 25 e: 26 i: 26 e: 27 i: 27 e: 28 i: 28 e: 29 i: 29 e: 30
i: 30 e: 31 i: 31 e: 32 i: 32 e: 33 i: 33 e: 34 i: 34 e: 35
i: 35 e: 36 i: 36 e: 37 i: 37 e: 38 i: 38 e: 39 i: 39 e: 40
i: 40 e: 41 i: 41 e: 42 i: 42 e: 43 i: 43 e: 44 i: 44 e: 45
i: 45 e: 46 i: 46 e: 47 i: 47 e: 48 i: 48 e: 49 i: 49 e: 50
i: 50 e: 51 i: 51 e: 52 i: 52 e: 53 i: 53 e: 54 i: 54 e: 55
i: 55 e: 56 i: 56 e: 57 i: 57 e: 58 i: 58 e: 59 i: 59 e: 60
i: 60 e: 61 i: 61 e: 62 i: 62 e: 63 i: 63 e: 64 i: 64 e: 65
i: 65 e: 66 i: 66 e: 67 i: 67 e: 68 i: 68 e: 69 i: 69 e: 70

capacity: 80 size: 70

i: 0 e: 13 i: 1 e: 14 i: 2 e: 18 i: 3 e: 19 i: 4 e: 24
i: 5 e: 26 i: 6 e: 30 i: 7 e: 31 i: 8 e: 34 i: 9 e: 35
i: 10 e: 36 i: 11 e: 48 i: 12 e: 63 i: 13 e: 64 i: 14 e: 67
i: 15 e: 70
capacity: 40 size: 16
```

#### 5.1.4 获取和查找元素

1. 获取元素

```c
Data get(List *list, int index) {
    if (index < 0 || index >= list->size) {
        return -1;
    }
    return list->array[index];
}
```

2. 循序查找元素

```c
Data findElem(List *list, Data e) {
    for (int i = 0; i < list->size; i++) {
        if (list->array[i] == e) {
            return i;
        }
    }
    return -1;
}
```

测试功能

```c
int main() {
    List list;
    init(&list);
    for (int i = 0; i < 30; ++i) {
        insert(&list, i + 1, i);
    }
    print(&list);
    int pos = findElem(&list, 10);
    printf("pos: %d", pos);
    return 0;
}
```

输出

```
i: 0 e: 1 i: 1 e: 2 i: 2 e: 3 i: 3 e: 4 i: 4 e: 5
i: 5 e: 6 i: 6 e: 7 i: 7 e: 8 i: 8 e: 9 i: 9 e: 10
i: 10 e: 11 i: 11 e: 12 i: 12 e: 13 i: 13 e: 14 i: 14 e: 15
i: 15 e: 16 i: 16 e: 17 i: 17 e: 18 i: 18 e: 19 i: 19 e: 20
i: 20 e: 21 i: 21 e: 22 i: 22 e: 23 i: 23 e: 24 i: 24 e: 25
i: 25 e: 26 i: 26 e: 27 i: 27 e: 28 i: 28 e: 29 i: 29 e: 30

pos: 9
```

#### 5.1.5 分析

操作上面的顺序表的时间复杂度

- 插入：因为需要将所有元素都向后移动，所以是`o(n)`

- 删除：和插入同理，是`o(n)`
- 查找元素：需要遍历所有元素，是`o(n)`
- 获取元素：`o(1)`

在长度为n的顺序表中，向第i个元素插入一个元素，需要向后移动`n-i`个元素

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/61c47fc63bd07c728dc9e087e762147c.png)

### 5.2 链表

链表不同于顺序表，**顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要**，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。**它不需要申请连续的空间，只需要按照顺序连接即可**，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表)。

链表分为带头结点的链表和不带头结点的链表，带头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据:

#### 5.2.1 创建链表

1. 定义结构和初始化函数

```c
typedef struct Node {
    Data data;
    int length;
    struct Node *next;
}Node;

_Bool init(Node *head) {
    head->next = NULL;
    head->length = 0;
    return 1;
}
```

#### 5.2.2 插入元素和遍历元素

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e318c64ed593ed4c87d28c022f1a4bb8.png)

1. 编写插入元素函数

```c
_Bool insert(Node *head, Data e, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head == NULL)   // 判断插入位置是否合法
            return 0;
    }
    Node *newNode = (Node *) malloc(sizeof(Node));
    if (newNode == NULL)    // 判断内存是否分配成功
        return 0;
    newNode->data = e;
    newNode->next = head->next; // 将新节点的next指针指向head的next指针所指向的节点
    head->next = newNode;   // 将head的next指针指向新节点
    return 1;
}
```

2. 编写遍历函数

```c
void print(Node *head) {
    int i = 0;
    while (head->next != NULL) {
        head = head->next;
        printf("i: %d e: %d  ", i, head->data);
        if (i++ && i % 5 == 0)
            printf("\n");
    }
    printf("\n\n");
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    insert(&head, 1, 0);
    insert(&head, 2, 1);
    insert(&head, 3, 2);
    insert(&head, 4, 3);
    insert(&head, 5, 4);
    print(&head);
    return 0;
}
```

输出

```
1
2
3
4
5
```

#### 5.2.3 删除元素

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d68caaa846ad076b9b2696276a1b6bfc.png)

1. 编写删除函数

```c
_Bool delete(Node *head, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head == NULL)   // 判断删除位置是否合法
            return 0;
    }
    if (head->next == NULL) // 判断删除位置是否合法
        return 0;
    Node *tmp = head->next;         // 保存被删节点的地址
    head->next = head->next->next;  // 指向被删元素的下一个节点
    free(tmp);                      // 释放被删节点的内存
    return 1;
}
```

2. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 23; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    for (int i = 0; i < 13; ++i) {
        delete(&head, 0);
    }
    print(&head);
    return 0;
}
```

输出

```
i: 0 e: 1  i: 1 e: 2  i: 2 e: 3  i: 3 e: 4  i: 4 e: 5
i: 5 e: 6  i: 6 e: 7  i: 7 e: 8  i: 8 e: 9  i: 9 e: 10
i: 10 e: 11  i: 11 e: 12  i: 12 e: 13  i: 13 e: 14  i: 14 e: 15
i: 15 e: 16  i: 16 e: 17  i: 17 e: 18  i: 18 e: 19  i: 19 e: 20
i: 20 e: 21  i: 21 e: 22  i: 22 e: 23

i: 0 e: 14  i: 1 e: 15  i: 2 e: 16  i: 3 e: 17  i: 4 e: 18
i: 5 e: 19  i: 6 e: 20  i: 7 e: 21  i: 8 e: 22  i: 9 e: 23

```

#### 5.2.4 获取和查找元素

1. 获取函数

```c
Data get(Node *head, int index) {
    if (index < 0)
        return INT_MAX;
    for (; head->next && index; index--) {  // 判断index是否合法
        head = head->next;
        if (head->next == NULL)             // 如果发生越界返回INT_MAX
            return INT_MAX;
    }
    return head->next->data;
}
```

2. 查找函数

```c
int findElem(Node *head, Data e) {
    for (int i = 0; head->next; i++, head = head->next) {
        if (head->next->data == e) {
            return i;
        }
    }
    return -1;
}
```

#### 5.2.5 获取长度

```c
int len(Node *head) {
    int i = 0;
    for (; head->next; i++, head = head->next);
    return i;
}
```

#### 5.2.6 分析

操作链表的事件复杂度

- 插入，需要向前循环查找节点，复杂度为`o(n)`，但是没有赋值操作，效率比顺序表高
- 删除，和插入同理，事件复杂度为`o(n)`
- 获取元素，也需要循环遍历，复杂度为`o(n)`

什么时候用顺序表、链表

- 通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。
- 而顺序表在插入元素时就显得有些戏肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。

### 5.3 双向链表

为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针:

#### 5.3.1 创建双向链表

```c
typedef struct Node {
    Data data;
    struct Node *prev;
    struct Node *next;
} Node;

void init(Node *head) {
    head->prev = head->next = NULL;
}
```

#### 5.3.2 插入元素

1. 编写插入函数

```c
_Bool insert(Node *head, Data e, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        if (head->next == NULL)
            return 0;
        head = head->next;
    }
    Node *newNode = (Node *) malloc(sizeof(Node));
    if (newNode == NULL)
        return 0;
    newNode->data = e;
    // 插入节点
    if (head->next != NULL) {   // 插入的不是最后一个节点
        newNode->next = head->next;
        head->next->prev = newNode;
    } else {
        newNode->next = NULL;
    }
    head->next = newNode;
    newNode->prev = head;
    return 1;
}
```

2. 编写遍历函数(顺序和逆序)

```c
void print(Node *head) {
    int i = 0;
    printf("\nsequence:\n");
    for (; head->next; i++, head = head->next) {
        printf("i: %d e: %d\t|| ", i, head->next->data);
        if (i && (i + 1) % 5 == 0)
            printf("\n");
    }
    printf("\nreverse:\n");
    for (i--; head->prev; --i, head = head->prev) {
        printf("i: %d e: %d\t|| ", i, head->data);
        if (i && i % 5 == 0)
            printf("\n");
    }
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 30; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    return 0;
}
```

输出

```
sequence:
i: 0 e: 1       || i: 1 e: 2    || i: 2 e: 3    || i: 3 e: 4    || i: 4 e: 5    ||
i: 5 e: 6       || i: 6 e: 7    || i: 7 e: 8    || i: 8 e: 9    || i: 9 e: 10   ||
i: 10 e: 11     || i: 11 e: 12  || i: 12 e: 13  || i: 13 e: 14  || i: 14 e: 15  ||
i: 15 e: 16     || i: 16 e: 17  || i: 17 e: 18  || i: 18 e: 19  || i: 19 e: 20  ||
i: 20 e: 21     || i: 21 e: 22  || i: 22 e: 23  || i: 23 e: 24  || i: 24 e: 25  ||
i: 25 e: 26     || i: 26 e: 27  || i: 27 e: 28  || i: 28 e: 29  || i: 29 e: 30  ||

reverse:
i: 29 e: 30     || i: 28 e: 29  || i: 27 e: 28  || i: 26 e: 27  || i: 25 e: 26  ||
i: 24 e: 25     || i: 23 e: 24  || i: 22 e: 23  || i: 21 e: 22  || i: 20 e: 21  ||
i: 19 e: 20     || i: 18 e: 19  || i: 17 e: 18  || i: 16 e: 17  || i: 15 e: 16  ||
i: 14 e: 15     || i: 13 e: 14  || i: 12 e: 13  || i: 11 e: 12  || i: 10 e: 11  ||
i: 9 e: 10      || i: 8 e: 9    || i: 7 e: 8    || i: 6 e: 7    || i: 5 e: 6    ||
i: 4 e: 5       || i: 3 e: 4    || i: 2 e: 3    || i: 1 e: 2    || i: 0 e: 1    ||
```

#### 5.3.3 删除元素

1. 编写删除函数

```c
_Bool delete(Node *head, int index) {
    if (index < 0)
        return 0;
    while (index--) {
        head = head->next;
        if (head->next == NULL)
            return 0;
    }
    if (head->next == NULL)
        return 0;
    Node *tmp = head->next;
    // 将节点从逻辑上删除
    if (head->next->next)       // 待删除节点的后继节点是否存在
    {
        head->next->next->prev = head;
        head->next = head->next->next;
    } else {
        head->next = NULL;
    }
    // 释放内存
    free(tmp);
    return 1;
}
```

2. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 13; ++i) {
        insert(&head, i + 1, i);
    }
    print(&head);
    delete(&head, 12);
    print(&head);
    return 0;
}
```

```
sequence:
|i: 0 e: 1      | |i: 1 e: 2    | |i: 2 e: 3    | |i: 3 e: 4    | |i: 4 e: 5    |
|i: 5 e: 6      | |i: 6 e: 7    | |i: 7 e: 8    | |i: 8 e: 9    | |i: 9 e: 10   |
|i: 10 e: 11    | |i: 11 e: 12  | |i: 12 e: 13  |

sequence:
|i: 0 e: 1      | |i: 1 e: 2    | |i: 2 e: 3    | |i: 3 e: 4    | |i: 4 e: 5    |
|i: 5 e: 6      | |i: 6 e: 7    | |i: 7 e: 8    | |i: 8 e: 9    | |i: 9 e: 10   |
|i: 10 e: 11    | |i: 11 e: 12  |
```



#### 5.3.4 循环链表

最后一个节点指向头节点的链表

**// TODO**

## 6. 特殊线性表

### 6.1 栈

栈

- 是一种特殊的线性表，它只能在表尾进行插入和删除操作

#### 6.1.1 创建栈

1. 创建栈

```c
typedef struct Stack {
    Data *data;
    int capacity;
    int top; // 存栈顶的下标
} Stack;

_Bool init(Stack *stack) {
    stack->data = (int *) malloc(sizeof(Data) * 10);
    if (stack->data == NULL)
        return 0;
    stack->capacity = 10;
    stack->top = -1;
    return 1;
}
```

2. 遍历函数

```c
void print(Stack *stack) {
    for (int i = stack->top; i >= 0; --i) {
        printf("+------+\n");
        printf("| %4d |\n", stack->data[i]);
    }
    printf("+------+\n");
    printf("top: %d capacity: %d\n", stack->top, stack->capacity);
}
```



#### 6.1.2 入栈出栈

1. 入栈

```c
_Bool push(Stack *stack, Data e) {
    //判断是否需要扩容
    if (stack->top + 1 == stack->capacity) {
        stack->capacity = stack->capacity + (stack->capacity >> 1); // 容量增加1.5倍
        Data *data = (Data *) realloc(stack->data, sizeof(Data) * stack->capacity);// 重新申请内存
        if (data == NULL)
            return 0;
        stack->data = data;
    }
    stack->data[++stack->top] = e;
    return 1;
}
```

2. 出栈

```c
Data pop(Stack *stack) {
    // 判断是否需要减容
    if (stack->top <= stack->capacity / 2) {
        stack->capacity /= 2;
        Data *data = (Data *) realloc(stack->data, sizeof(Data) * stack->capacity);
        if (data == NULL)
            return INT_MAX;
        stack->data = data;
    }
    return stack->data[stack->top--];
}
```

3. 测试功能

```c
int main() {

    Stack stack;
    init(&stack);
    for (int i = 100; i < 110; ++i) {
        push(&stack, i);
    }
    print(&stack);
    for (int i = 0; i < 5; ++i) {
        printf("%d\n", pop(&stack));
    }
    print(&stack);
    return 0;
}
```

输出

```
+------+
|  109 |
+------+
|  108 |
+------+
|  107 |
+------+
|  106 |
+------+
|  105 |
+------+
|  104 |
+------+
|  103 |
+------+
|  102 |
+------+
|  101 |
+------+
|  100 |
+------+
top: 9 capacity: 10

109
108
107
106
105
+------+
|  104 |
+------+
|  103 |
+------+
|  102 |
+------+
|  101 |
+------+
|  100 |
+------+
top: 4 capacity: 5
```

### 6.2 栈(链表实现)

#### 6.2.1 创建栈

1. 创建栈

 ```c
 typedef struct Node {
     Data data;
     struct Node *next;
 } Node;
 
 void init(Node *head) {
     head->next = NULL;
 }
 ```

2. 遍历函数

```c
void print(Node *head) {
    head = head->next;
    for (; head; head = head->next) {
        printf("+------+\n");
        printf("| %4d |\n", head->data);
    }
    printf("+------+\n");
}
```

#### 6.2.2 入栈出栈

1. 入栈

```c
_Bool push(Node *head, Data e) {
    Node *node = (Node *) malloc(sizeof(Node));
    if (node == NULL)
        return 0;
    node->data = e;
    node->next = head->next;
    head->next = node;
}
```

2. 出栈

```c
Data pop(Node *head) {
    Node *tmp = head->next;
    Data e = tmp->data;
    head->next = head->next->next;
    free(tmp);
    return e;
}
```

3. 测试功能

```c
int main() {
    Node head;
    init(&head);
    for (int i = 0; i < 10; ++i) {
        push(&head, i);
    }
    print(&head);
    for (int i = 0; i < 5; ++i) {
        printf("%d\n", pop(&head));
    }
    print(&head);
    return 0;
}
```

输出

```
+------+
|    9 |
+------+
|    8 |
+------+
|    7 |
+------+
|    6 |
+------+
|    5 |
+------+
|    4 |
+------+
|    3 |
+------+
|    2 |
+------+
|    1 |
+------+
|    0 |
+------+
9
8
7
6
5
+------+
|    4 |
+------+
|    3 |
+------+
|    2 |
+------+
|    1 |
+------+
|    0 |
+------+
```

### 6.3 队列

队列(Queue)是一种特殊的线性表

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/92010e859098a2f4b0e327295bf9df1e.png)

秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出(FIFO，First In, First Out)的数据结构。

顺序表实现方式

1. 假设一开始的时候队列有0个元素，队首和队尾一般都初始都是-1这个位置:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fb20ec4fcd6a085a3781364b3347a2cc.png)

2. 此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e0623a179826ea8906d54ec40493e13a.png)



3. 之后都是以同样的方式进行插入，队尾会一直向后移动

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/aeca464b8a7082bf5a56610f0ac6edb6.png)

4. 现在我们想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/41c7fa2f9a569e0e6b90c79dd5c694c7.png)

5. 看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧?所以一般我们采用循环队列的形式，来实现重复使用一个数组(不过就没办法扩容了，大小是固定的)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/24ee30d2d73a79028e5ffd527d5aaaa3.png)

6. 我们可以在移动队首队尾指针时，考虑循环的问题，也就是说如果到达了数组尽头，那么就直接从数组的前面重新开始计算，这样就相当于逻辑上都循环了，队首和队尾指针在一开始的时候都指向同一个位置，每入队一个新的元素，依然是先让队尾后移一位，在所指向位置插入元素，出队同理。

7. 由于队首指针和队尾指针重合时表示队列为空，所以我们只能舍弃一个存储单元，当队尾距离队首一个单元的时候，表示队列已满。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/13bd8ed8a3cd1670fed71e45d60e5c7b.png)





#### 6.3.1 创建队列（循环队列）

使用的是循环队列

1. 创建队列

```c
typedef int Data;

typedef struct Queue {
    Data *data;
    int capacity; // 容量
    int rear, front; // 队尾，队头

} Queue;

/***
 * @brief 初始化队列
 * @param queue 队列
 * @return
 */

_Bool initQueue(Queue *queue) {
    queue->data = malloc(sizeof(Data) * 10);
    if (queue->data == NULL) {
        return 0;
    }
    queue->capacity = 10;
    queue->rear = queue->front = 0;
    return 1;
}
```

2. 遍历队列

```c
/***
 * @brief 遍历队列
 * @param queue 队列
 * @return
 */

void print(Queue *queue) {
    int i = queue->front;
    printf("<<<");
    do {
        i = (i + 1) % queue->capacity;
        printf("%d ", queue->data[i]);
    } while (i != queue->rear);
    printf(">>>\n");
}
```



#### 6.3.2 入队出队

1. 入队

```c
/***
 * @brief 入队
 * @param queue 队列
 * @param data 数据
 * @return
 */

_Bool offerQueue(Queue *queue, Data data) {
    int pos = (queue->rear + 1) % queue->capacity;
    if (pos == queue->front) {
        return 0;
    }
    queue->rear = pos;
    queue->data[queue->rear] = data;
    return 1;
}
```

2. 出队

```c
/***
 * @brief 出队
 * @param queue 队列
 * @return
 */

Data pollQueue(Queue *queue) {
    queue->front = (queue->front + 1) % queue->capacity;
    return queue->data[queue->front];
}
```



简洁循环队列版本

```c++
typedef int T;
typedef struct cQueue {
    T *data;
    int front, rear;
} *Queue;

void initQueue(Queue queue) {
    queue->data = static_cast<T *>(malloc(sizeof(T) * 5));
    queue->front = queue->rear = 0;
}

void offerQueue(Queue queue, T data) {
    int pos = (queue->rear) % 5;
    queue->data[pos] = data;
    queue->rear = (queue->rear + 1) % 5; // 保证rear后面有一个空位
}

void pollQueue(Queue queue) {
    if (queue->front == queue->rear) return; // 队列为空, 不能出队
    queue->front = (queue->front + 1) % 5; // 向后移动一位
}

int size(Queue queue) {
    return (queue->rear - queue->front + 5) % 5; // 计算队列长度
}

void print(Queue queue) {
    for (int i = queue->front; i != queue->rear; i++) {
        printf("%d ", queue->data[i]);
    }
    printf("\n");
}

int main() {
    struct cQueue queue{};
    initQueue(&queue);
    offerQueue(&queue, 1);
    offerQueue(&queue, 2);
    offerQueue(&queue, 3);
    offerQueue(&queue, 4);
    offerQueue(&queue, 5);
    offerQueue(&queue, 6);
    offerQueue(&queue, 7);
    offerQueue(&queue, 8);
    offerQueue(&queue, 9);

    print(&queue);
    printf("%d\n", size(&queue));

    pollQueue(&queue);
    print(&queue);
    printf("%d\n", size(&queue));

    return 0;
}
```



### 6.4 队列(链表实现)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/06010b07b61d963f0de805c7ceb28f62.png)

1. 注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。
2. 当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/765dd16b1f87fc77906431bff9a72ff0.png)

3. 出队时，只需要移除队首指向的下一个元素即可

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d1cbb704c55f6beef218d8a3382a1c07.png)



#### 6.4.1 创建队列

1. 创建队列

```c
typedef int Data;

typedef struct LNode {
    Data data;
    struct LNode *next;
} LNode;

typedef struct Queue {
    LNode *front;
    LNode *rear;
} Queue;

/***
 * @brief 初始化队列
 * @param queue 队列
 * @return
 */

_Bool initQueue(Queue *queue) {
    LNode *node = malloc(sizeof(LNode));
    if (node == NULL) {
        return 0;
    }
    queue->front = queue->rear = node;
    return 1;
}
```

2. 遍历队列

```c
/***
 * @brief 遍历队列
 * @param queue 队列
 */

void print(Queue *queue) {
    printf("<<<");
    LNode *node = queue->front->next;
    while (node != NULL) {
        printf("%d ", node->data);
        node = node->next;
    }
    printf(">>>\n");
}
```



#### 6.4.2 入队出队

1. 入队

```c
/***
 * @brief 入队
 * @param queue 队列
 * @param data 数据
 * @return
 */

_Bool offerQueue(Queue *queue, Data data) {
    LNode *node = malloc(sizeof(LNode));
    if (node == NULL) {
        return 0;
    }
    node->data = data;
    queue->rear->next = node;
    queue->rear = node;
    queue->rear->next = NULL;
    return 1;
}
```

2. 出队

```c
_Bool isEmpty(Queue *queue) {
    return queue->front == queue->rear;
}

/***
 * @brief 出队
 * @param queue 队列
 */

Data pollQueue(Queue *queue) {
    if (isEmpty(queue)) {
        return INT_MAX;
    }
    LNode *node = queue->front->next;
    Data data = node->data;
    queue->front->next = node->next;
    if (queue->rear == node) {
        queue->rear = queue->front;
    }
    free(node);
    return data;
}
```



## 7. 树形结构

### 7.1 树和森林

**树**

<img src="https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5c2a0bcd8c290d6360c0e78df97166f1.png" style="zoom:50%;" />

可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为**树**(Tree)注意分支只能向后单独延伸，之后就分道扬镳了，**不能与其他分支上的结点相交**!

- 我们一般称位于最上方的结点为树的**根结点**（Root）因为整棵树正是从这里开始延伸出去的。
- 每个结点连接的子结点数目(分支的数目)，我们称为结点的**度**(Degree)，而各个结点度的最大值称为树的度。
- 每个结点延伸下去的下一个结点都可以称为一棵**子树**（SubTree）比如结点B及其之后延伸的所有分支合在一起，就是一棵A的子树。
- 每个**结点的层次**（Level）按照从上往下的顺序，树的根结点为1，每向下一层+1，比如G的层次就是3，整棵树中所有结点的最大层次，就是这颗树的**深度**（Depth），比如上面这棵树的深度为4，因为最大层次就是4

节点之间的称谓

- 与当前节点直接向下连接的节点为**子节点**，相反直接向上连接的节点就是**父节点**
- 没有任何子节点（节点度为0）的节点为**叶子节点**
- 父节点为同一个的节点之间称**兄弟节点**
- 向上直到根节点的所有节点，称为**祖先节点**



**森林**

m(m>0)棵树的集合称为森林

### 7.2 二叉树

#### 7.2.1 二叉树概念

**二叉树**（Binary Tree）

- 度最大为2
- 有左右之分，称为**左子树**、或者**右子树**

几种基本形态

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b475390ae6891776c452422b1acc712e.png)

二叉树的称称谓

- **满二叉树**，整颗树都很饱满，没有出现度为1的节点

<img src="https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6c97d21828aa67fb792f602e6c8301c8.png" style="zoom:50%;" />

- **完全二叉树**，只有最后一层空缺，且所有叶子节点都是从左到右的顺序排列，满二叉树就是完全二叉树

<img src="https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/afd0b176579e627a547615c844534f43.png" style="zoom:50%;" />

#### 7.2.2 树和森林的转换

二叉树和树、森林之间是可以互相转换的

##### 7.2.2.1 树转换为二叉树

1. 方式一：兄弟节点转为右子节点，子节点转为左子节点
   - 最左边孩子结点 -> 左子树结点 (左孩子)
   - 兄弟结点 -> 右子树结点 (右孩子)

以下面这棵树为例

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/42d2683c4068d3139aca3d1eadc21c43.png)

我们优先从左边开始看，B、F、G都是A的子结点，根据上面的规律，我们将B作为左子树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e6e169190aa2c6a291d3b4fa8809d139.png)

接着继续从左往右看，由于F是B的兄弟结点，那么根据规律，F作为B的右子树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/04a5270e002eb83bfd2df32b951f2e0b.png)

接着是G，G是F的兄弟结点，那么G继续作为F的右子树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/45e470527ed28e599f114d607b8b870a.png)

我们接着来看第三排，依然是从左往右，C是B的子节点，所以C作为B的左子树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/190efdeff7a626e96cea968e866973d3.png)

接着，D是C的兄弟结点，那么D就作为C的右子树了

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/624a2bd70764f229b6e725cb0fcc3fa8.png)

此时还有一个H结点，他是G的子节点，所以直接作为G的左子树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ce4da39a0c1b6d10e37c7d92e70f44e8.png)

现在只剩下最后一排了，E是D的子节点，K是H的子节点，所以最后就像这样了

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/15263219eb3a1e60425b67642dd03640.png)



2. 方式二：兄弟节点之间相互连线，擦除右节点的连线，拉直树即可

将所有兄弟结点连起来(橙色横线)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f72ed476b239877625b6fcbcb91905f0.png)

接着擦掉除了最左边结点以外的连线

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3964d3c0fcd364e85156bdc7f15c60ce.png)

所有的黑色连线偏向左边，橙色连线偏向右边

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/52ddff1db58946d8ba1b850735824f28.png)



##### 7.2.2.2 二叉树转为树

- 反推即可

##### 7.2.2.3 森林转为二叉树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ca108c4ce44066bd7c0a9f9768c14098.png)

首先，还是按照二叉树转换规则，将森林中所有树转换为二叉树，接着我们只需要依次连接即可

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f2e6d6c057b5f42e3f6d3cab03db0f42.png)

##### 7.2.2.4 从树转为二叉树和从森林转为二叉树的区别

- 从树转为二叉树，二叉树没有右子树

- 从森林转为二叉树，二叉树有右子树

#### 7.2.3 二叉树数学性质

**五个性质**

- **性质一：**第$i$层的最大节点数量为$2^{i-1}$个，比如二叉树的第一层只有一个根节点，也就是$2^0=1$，而二叉树的第三层可以有$2^2=4$个节点
- **性质二：**对于一棵深度为$k$的二叉树，可以具有的最大节点数为：

$$
n=2^0+2^1+2^2+...+2^{k-1}
$$

每层节点的数量，组成了等比数列，公比为2
$$
s_n=\frac{a_1\times{(1-q_n)}}{1-q}=\frac{1\times{(1-2^k)}}{1-2}=-(1-2^k)=2^k-1
$$
所以一棵深度为$k$的二叉树的最大节点数量为$n=2^k-1$，节点边数为$E=n-1$

- **性质三：**假设一棵二叉数中度为0、1、2的节点数量分别为$n_0、n_1、n_2$，由于一棵二叉树中只有这三种类型的节点，那么可以直接得到节点总数

$$
n=n_0+n_1+n_2
$$

因为每个结点有且仅有一条变与父节点相连，那么边数之和就可以表示为
$$
E=n_1+2n_2
$$
度为1的结点有一条边，度为2的结点有两条边，度为0的结点没有，加在一起就是整颗二叉树的边数之和，结合**性质二**中推导的结果，可以得到另一种计算结点总数的方式
$$
E=n-1=n_1+2n_2
$$

$$
n=n_1+2n_2+1
$$

在结合第一个公式
$$
n=n_0+n_1+n_2=n_1+2n_2+1
$$
**综上，对于任何一棵二叉树，如果其叶子结点个数为$n_0$，度为2的结点个数为$n_2$，那么二者满足以下公式**
$$
n_0=n_2+1
$$


- **性质四：**完全二叉树除了最后一层有空缺外，其他层数都是饱满的，假设这棵二叉树为满二叉树，那么根据我们前面得到的性质，假设层数为$k$，那么结点数量为:$n=2^k-1$，根据完全二叉树的性质，最后一层可以满可以不满，那么一棵完全二叉树结点数n满足:

$$
2^{k-1}-1<n<=2^k-1
$$

因为$n$肯定是一个整数，那么可以写成
$$
2^{k-1}<=n<=2^k-1
$$
只看左边的不等式，我们对两边取对数，得到
$$
k-1<=\log_2n
$$
**综上所属，一棵具有$n$个结点的完全二叉树深度为**
$$
k=\lfloor\log_2n\rfloor+1
$$


- **性质五：**一颗有$n$个结点的完全二叉树，由性质四得到深度为$k= \lfloor{log_2n}\rfloor+1$现在对于任意一个结点$i$，结点的顺序为从上往下，从左往右:
  - 对于一个拥有左右孩子的结点来说，**其左孩子为$2i$ ，右孩子为$2i + 1$**。
  - 如果$i = 1$，那么此结点为二叉树的根结点，**如果$i>1$，那么其父结点就是$\lfloor{i/2}\rfloor$**，比如第3个结点的父结点为第1个节点,也就是根结点。
  - **如果$2i > n$，则结点主没有左孩子**，比如下面图中的二叉树，$n$为5，假设此时$i = 3$，那么$2i = 6 > n = 5$说明第三个结点没有左子树。
  - **如果$2i +1 > n$，则结点$i$没有右孩子**。

<img src="https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bb0ebf1a3d24e5878ed78209b482e167.png" alt="image-20230323232747845" style="zoom:50%;" />



#### 7.2.4 二叉树练习题

##### 7.2.4.1 练习题一

**由三个结点可以构造出多少种不同的二叉树？**

- 手画可以得出是5个
- 如果求N个结点，可以使用动态规划的方法
  - 假设现在只有一个结点或者没有结点，那么只有一种，$h(0)=h(1)=1$
  - 假设现在有两个结点，那么其中一个拿来做根节点，剩下这一个可以左边可以右边，要么左边零个结点右边一个结点，要么左边一个结点右边零个结点，所以说$h(2)=h(1)\times h(0) + h(0)\times h(1)=2$
  - 假设现在有三个结点，那么依然是其中一个拿来做根节点，剩下的两个结点情况就多了，要么两个都在左边，两个都在右边，或者一边一个，所以说$h(3)=h(2)\times h(0) + h(1)\times h(1) + h(0)\times h(2)=5$
  - **我们发现，他说非常有规律的，N每+1，项数多一项，所以我们只需要按照规律把所有情况的结果相加就行了**，我们按照上面推到的结果，编写代码

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n); // 读入需要计算的二叉树层数
    int dp[n + 1];
    dp[0] = dp[1] = 1; // 没有结点或是只有一个结点的二叉树只有一种情况
    for (int i = 2; i <= n; i++) {
        dp[i] = 0; // 初始化为0
// 内层循环是为了计算所有情况，比如i等于3时，那么就从j = 0开始，计算dp[0]和dp[2]的结果，
// 再计算dp[1]和dp[1]的结果，最后计算dp[2]和dp[0]的结果
        for (int j = 0; j < i; j++) {
            dp[i] += dp[i - j - 1] * dp[j];
        }
    }
    printf("%d\n", dp[n]); // 输出n层二叉树的情况数
    return 0;
}
```

> 求出结果序列为：1、1、2、5、14、42、132...，这种类型的数列我们称为**卡特兰数**，以中国蒙古族数学家明安图(1692-1763)和比利时的数学家欧仁·查理·卡塔兰(1814-1894)的名字来命名，**它的通项公式为**:

$$
C_n=\frac{1}{n+1}C^n_{2n}=\frac{1}{n+1}\times \frac{(2n)!}{n!\times (2n-n)!}=\frac{(2n!)}{n!\times (n+1)!}
$$

所以不需要动态规划了，直接一个算式解决问题

```c
#include <stdio.h>

int fac(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * fac(n - 1);
    }
}

int main() {
    int n;
    scanf("%d", &n);
    printf("%d", fac(2 * n) / (fac(n) * fac(n + 1)));
    return 0;
}
```



##### 7.2.4.2 练习题二

**一棵完全二叉树有1001个结点，其中叶子结点的个数为？**

> 既然是完全二叉树，那么最下面这一排肯定是按顺序排的，并且上面各层应该是排满了的，那么我们先求出层数，根据性质四：

$$
k = \lfloor log_2n\rfloor + 1 = 9 + 1 = 10
$$

> 所以此二叉树的层数为10，也就是说上面9层都是满满当当的，最后一层不满，那么根据性质二，我们求出前9层的结点数：

$$
n = 2^k - 1 = 511
$$

> 那么剩下的结点就都是第10层的了，等到第10层所有叶子结点数量$=1001-511=490$，因为第10层并不满，剩下的叶子第9层也有，所以最后我们还需要求出第9层的叶子结点数量，先计算第9层的所有结点数量

$$
n=2^{i-1}=256
$$

> 接着我们需要去掉那些第9层度为1和度为2的结点，其实只需要让第10层的叶子结点除以2即可

$$
n=(490+1)/2=245
$$

> 注意在除的时候+1，因为有可能会出现一个度为1的结点，此时也需要剔除，所以说+1变成偶数这样才可以正确得到结果。最后剔除这些结点，道道最终结果

$$
n_0=256-245+490=501
$$



##### 7.2.4.3 练习题三

**深度为h的满m叉树的第k层有多少个结点？**

- 满二叉树性质

$$
n=2^{i-1}
$$

> m叉树，以三叉树为例，每向下一层，就划分三个孩子结点出来，每一层的最大结点数依次为：1、3、9、27...

所以满m叉树的第k层的结点数：
$$
n=m^{k-1}
$$


##### 7.2.4.4 练习题四

**一棵有1025个结点的二叉树的层数k的取值范围是？**

>  根据性质四$k=\lfloor\log_2n\rfloor+1$ ，得到最小深度为11，最大深度就是1025，所以$k$的范围是$11-1025$



##### 7.2.4.5 练习题五

**将一棵树转换为二叉树时，根结点的右边连接的是？**

> 根据我们前面总结的性质，树转换为二叉树之后，根结点一定没有右子树，所以为空



#### 7.2.5 代码实现二叉树

二叉树的存储形式也可以使用我们前面的两种方式，**一种是使用数组进行存放**，**还有一种就是使用链式结构**只不过之前链式结构需要强化一下才可以表示为二叉树。

##### 7.2.5.1 定义二叉树和初始化二叉树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/24152a9b4530fd79044bda7a3f42cdf9.png)

1. 定义二叉树

```c
typedef char Data;

typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
} TN;

/***
 * @brief 二叉树的创建
 * @return TN* 返回二叉树的根节点
 */
TN *createTree() {
    TN *root = malloc(sizeof(TN));
    Data data = 0;
    root->data = data;
    root->left = NULL;
    root->right = NULL;
    return root;
}
```

2. 向二叉树传值

```c
int main() {
    TN *a = createTree();
    a->data = 'a';
    TN *b = createTree();
    b->data = 'b';
    TN *c = createTree();
    c->data = 'c';
    TN *d = createTree();
    d->data = 'd';
    TN *e = createTree();
    e->data = 'e';
    
    a->left = b;
    a->right = c;
    b->left = d;
    b->right = e;
    printf("%c", a->left->right->data);
    return 0;
}
```



##### 7.2.5.2 遍历二叉树

由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：**前序遍历、中序遍历、后序遍历、层序遍历**。不同的访问方式输出的结点顺序也不一样。



###### 7.2.5.2.1 前序遍历

前序遍历是一种勇往之前的方式，走到哪就遍历到哪里，先走左边再走右边，比如下面这个图，首先会从根结点开始：

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6cd9d9cd9bf4531cc6f3ac8b9f7656e2.png)

先从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完了之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：`ABDECF`

即：

1. 打印节点
2. 遍历左子树
3. 遍历右子树

```c
/***
 * @brief 二叉树的前序遍历
 * @param curr 当前节点
 */

void preOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    printf("%c", curr->data);
    preOrder(curr->left); // 先走左边
    preOrder(curr->right); // 再走右边
}
```

```
abdecf
```



**使用循环和栈来实现前序遍历**

- 一路向左，不断入栈，直到结点为NULL
- 到NULL后，出栈，看有没有右子树，如果没有就继续出栈，知道遇到有右子树的为止
- 拿到右子树后，从右子树开始，重复上述步骤，知道栈清空

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8fd51b118f7212273c684d281840a4e5.png)

依然从根节点A出发，不断遍历左子树，沿途打印结果并将结点丢入栈中

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5d3b2cd7a442561e7dbfbbb4a29ee2a8.png)

当遍历到D结点时，没有左子树了，此时将栈顶结点D出栈，发现没有右节点，继续出栈，得到B结点，接着得到当前结点的右孩子E结点，然后重复上述步骤:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6b66d5490d564479ae74193de8c7468e.png)

接着发现E也没有左子树了，同样的，又开始出栈，此时E没有右子树，接着看A，A有右子树，所以继续从C开始，重复上述步骤:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ca193151d69772609f3984f749b4754d.png)

由于C之后没有左子树，那么就出栈获取右子树，此时得到结点F，继续重复上述步骤:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d3a01b667b10fb494d3314520c149878.png)

最后F出栈，没有右子树了，栈空，结束。



###### 7.2.5.2.2 中序遍历

中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/950d5c9f9c2b05ee2d093e7480a55cb0.png)

首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。

1. 遍历左子树
2. 打印结点
3. 遍历右子树

```c
/***
 * @brief 二叉树的中序遍历
 * @param curr 当前节点
 */

void inOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    inOrder(curr->left); // 先走左边
    printf("%c", curr->data);
    inOrder(curr->right); // 再走右边
}
```

```
dbeacf
```



###### 7.2.5.2.3 后序遍历

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a75e0fb053e76288629268b66377d5d4.png)

首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。|

1. 遍历左子树
2. 遍历右子树
3. 打印结点

```c
/***
 * @brief 二叉树的后序遍历
 * @param curr 当前节点
 */
void postOrder(TN *curr) {
    if (curr == NULL) { //  如果当前节点为空，直接返回
        return;
    }
    postOrder(curr->left); // 先走左边
    postOrder(curr->right); // 再走右边
    printf("%c", curr->data);
}
```

```
debfca
```



###### 7.2.5.2.4 层序遍历

这个遍历方式是人最容易理解的方式，一层一层从左到右的遍历

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a1f5b07ea91afbd0f841d09846fcf050.png)

我们可以利用队列来实现层序遍历，首先将根节点存入队列中，接着循环执行以下步骤

- 进行出队操作，得到一个结点，并打印结点的值
- 将此结点的左右孩子结点依次入队
- 不断重复以上步骤，直到队列为空

首先A在队首

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/af782d12ed3394d705383b491dfd064a.png)

接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/18fda399dd3442353351ff52758d7a05.png)

现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0f9e929ccf2283a775ff8f9ad9324d26.png)

现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/193db2b4e02c5ac3325fe4f8f9d150bf.png)

代码

```c++
#include <bits/stdc++.h>

using namespace std;
typedef char Data;
typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
    explicit TreeNode(Data data): data(data), left(nullptr), right(nullptr) {}
} TreeNode;

void levelOrder(TreeNode *root) {
    if (!root) return;

    queue<TreeNode *> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode *curr = q.front();
            q.pop();
            cout << curr->data << " ";
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        cout << endl;
    }
}

int main() {
    auto *root = new TreeNode('A');
    root->left = new TreeNode('B');
    root->right = new TreeNode('C');
    root->left->left = new TreeNode('D');
    root->left->right = new TreeNode('E');
    root->right->left = new TreeNode('F');
    root->right->right = new TreeNode('G');
    levelOrder(root);
    return 0;
}
```





### 7.3 高级树结构

#### 7.3.1 线索化二叉树

> 一棵二叉树的某些结点会存在`NULL`的情况，我们可以利用这些为`NULL`的指针，将其**线索化为某一种顺序遍历的指向下一个按顺序的结点的指针**，这样我们在进行遍历的时候，就会很方便了。

例如，一棵二叉树的前序遍历如下

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/491e443a168154bb62fb490b723b36fe.png)

我们就可以将其进行线索化，首先还是按照前序遍历的顺序依次寻找:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ccedad27eafd0d29f778dd3f34e4d6e6.png)

线索化的规则为:

- 结点的左指针，指向其当前遍历顺序的前驱结点。
- 结点的右指针，指向其当前遍历顺序的后继结点。

所以在线索化之后，G的指向情况如下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/252a8d37e521c8a944aa699c26a63e7a.png)

> 这样，G原本两个为`NULL`的指针就被我们利用起来了，但是现在有一个问题，我们怎么知道，某个结点的指针到底是指向的其左右孩子，还是说某种遍历顺序下的前驱或是后继结点呢?所以，我们还需要分别为左右添加一个标志位，来表示左右指针到底指向的是孩子还是遍历线索:

```c++
typedef char Data;

typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
    int leftTag, rightTag; // 标志位，如果为1表示这边指针指向的是线索，不为1就是正常孩子结点
} TreeNode;
```

> 接着是H结点，同样的，因为H结点的左右指针都是`NULL`，那么我们也可以将其线索化:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/83bc4fd3849d1a6505e77d26fc68748b.png)

> 接着我们来看结点E，这个结点只有一个右孩子，没有左孩子，左孩子指针为`NULL`，我们也可以将其线索化:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2689272599fc821569028d334e14d820.png)

> 最后，整棵二叉树完成线索化之后，除了遍历顺序的最后一个结点没有后续之外，其他为`NULL`的指针都被利用起来了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3d775154cc128d60e1d651845f679288.png)

> 我们可以发现，在利用上那些为`NULL`的指针之后，当我们再次进行前序遍历时，我们不需要再借助栈了，而是可以一路向前。

##### 7.3.1.1 前序遍历线索化

这里我们弄一个简单一点的线索化二叉树，来尝试对其进行遍历:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/be7fa064c2d5be9632d23da48c5fd2ff.png)

1. 创建节点，添加线索化

```c++
TreeNode *createNode(Data data) {
    auto *node = (TreeNode *) malloc(sizeof(struct TreeNode));
    node->data = data;
    node->left = node->right = nullptr;
    node->leftTag = node->rightTag = 0;
    return node;
}

int main() {
    TreeNode *root = createNode('A');
    root->left = createNode('B');
    root->right = createNode('C');
    root->left->left = createNode('D');
    root->left->right = createNode('E');

    return 0;
}
```

> 实际上要将其进行线索化，我们只需要正常按照对应的遍历顺序进行即可，不过在遍历过程中需要留意那些存在空指针的结点，我们需要修改其指针的指向:

```c++
void preOrderThreaded(Node root) {
    if (root == NULL) 
        return;
    // TODO
    preOrderThreaded(root->left);
    preOrderThreaded(root->right);
}
```

添加代码

```c++
Node pre = NULL; // 需要一个pre来保存后续节点的指向
void preOrderThreaded(Node root) {
    if (root == NULL) 
        return;
    // 先判断当前节点左边是否为NULL，如果是，那么指向上一个节点
    if (root -> left == NULL) {
		root -> left = pre;
        root -> leftTag = 1;
    }
    // 判断右边是否为NULL
    if (pre && pre-> right == NULL) {
        pre -> right = root;
        pre -> rightTag = 1;
    }
    // 遍历完一个节点，需要更新
    pre = root;
    // 需要判断标志位是否为0
    if (root -> leftTag == 0) {
        preOrderThreaded(root->left);
    }
    if (root -> rightTag == 0) {
        preOrderThreaded(root->right);
    }
}
```

2. 遍历线索二叉树

```c++
void preOrder(Node root) {
    while (root) {
        printf("%c", root->data);
        if (root->leftTag == 0) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
}
```

##### 7.3.1.2 中序遍历线索化

还是线索化上面的二叉树

```c++
Node pre = NULL;
void inOrderThreaded(Node root) {
    if (root == NULL)
        return;
    if (root->leftTag == 0) {
        inOrderThreaded(root->left);
    }
    // 将线索化的代码放在了中间位置
    if (root->left == NULL) {
        root->left = pre;
        root->leftTag = 1;
    }
    if (pre && pre->right == NULL) {
        pre->right = root;
        pre->rightTag = 1;
    }
    pre = root;
    if (root->rightTag == 0) {
        inOrderThreaded(root->right);
    }
}
```

线索化完了之后

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ce42e604aff78fc84ffac47ab59c310a.png)

遍历

```c++
void inOrder(Node root) {
    while(root) { // 因为中序遍历需要先完成左边，所以说要先走到最左边才行
        while (root && root -> leftTag == 0) {// 如果左边一直都不是线索，那么就一直往左找，直到找到一个左边是线索的为止，表示到头了
    		root = root -> left;
        }
        printf("%c",root -> data); // 到了最左边再打印，中序遍历开始
        while (root && root -> rightTag == 1) { // 打印完就该右边了，右边如果是线索化之后的结果，表示是下一个节点，那么就一路向前，直到不是为止
            root = root -> right;
            printf("%c", root -> data); // 沿途打印
        }
        root = root -> right; // 最后继续从右节点开始，重复上述操作
    }
}
```

##### 7.3.1.3 后序遍历线索化

```c++
Node pre = NULL;
void postOrderThreaded(Node root) {
    if (root == NULL)
        return;
    if (root->leftTag == 0) {
        postOrderThreaded(root->left);
    }
    if (root->rightTag == 0) {
        postOrderThreaded(root->right);
    }
    // 后序就将线索化过程放在最后
    if (root->left == NULL) {
        root->left = pre;
        root->leftTag = 1;
    }
    if (pre && pre->right == NULL) {
        pre->right = root;
        pre->rightTag = 1;
    }
    pre = root;
}
```

线索化完成之后，得到后序线索化二叉树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4ce016b2d408c13af4d907f03c7ee672.png)

> 后序遍历的结果看起来有点怪怪的，但是这就是后序，那么怎么对这棵线索化二叉树进行后续遍历呢?这就比较复杂了。首先后续遍历需要先完成左右，左边还好说，关键是右边，右边完事之后我们并不一定能找到对应子树的根结点，比如我们按照上面的线索，先从D开始，根据线索找到E，然后继续跟据线索找到B，**但是此时B无法找到其兄弟结点C，所以说这样是行不通的，因此要完成后续遍历，我们只能对结点进行改造**:

```c++
typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
    struct TreeNode *parent; // 指向双亲节点
    int leftTag, rightTag; // 标志位，如果为1表示这边指针指向的是线索，不为1就是正常孩子结点
} * Node;
```

然后再重新编写一下线索化代码

```c++
Node pre = NULL;
void postOrderThreaded(Node root) {
    if (root == NULL){
        return;
    }
    if (root->leftTag == 0) {
        postOrderThreaded(root->left);
        if (root->left) {
            root->left->parent = root; // 左边完成之后，如果不为空，那么就设定父子关系
        }
    }
    if (root->rightTag = 0) {
        postOrderThreaded(root->right);
        if (root->right) {
            root->right->parent = root; // 右边完成之后，如果不为空，那么就设定父子关系
        }
    }
    // -------- 线索化 --------
    if (root->left == NULL) {
        root->left = pre;
        root->leftTag = 1;
    }
    if (pre && pre->right == NULL) {
        pre->right = root;
        pre->rightTag = 1;
    }
    pre = root;
    // -----------------------
}
```

遍历代码

```c++
void postOrder(Node root) {
    Node last = NULL, node = root; // 这里需要两个暂存指针，一个记录上一次遍历的节点，还有一个从root开始
	while (node) {
        while (node->left != last && node->leftTag==0) {
            node = node->left;
        }
        while (node && node->rightTag == 1) { // 左边完了还有右边，如果右边是线索，那么直接一路向前，也是跟前面一样
            printf("%c", node->data);
            last = node;
            node = node->right;
        }
        if (node == root && node->right == last) {
            // 上面的操作完成之后，那么当前节点左右就结束了，此时就要去寻找其兄弟节点了，
            // 我们可以通过parenr拿到兄弟节点，但是如果当前节点是根节点，需要特殊处理，因为根节点没有父节点了
            printf("%c",node->data);
            return; // 根节点一定是最后一个，所以说直接返回就行
        }
        while(node && node->right == last) { // 如果当前节点的右孩子就是上一个遍历的节点，那么一直向前就行
            printf("%c",node->data);
            last = node;
            node = node->parent;
        }
        // 到这里只有一种情况了，是从左子树上来的，那么当前节点的右边那么是线索要么是右子树，所以直接向右就行
        if(node && node->rightTag == 0) { // 如果不是线索，那么就先走右边，如果是，等到下一轮
            node = node->right;
        }
    }
}
```



#### 7.3.2 二叉查找树

**二叉查找树**也叫二叉搜索树或是二叉排序树,它具有一定的规则：

- 左子树中所有结点的值，均小于其根结点的值。
- 右子树中所有结点的值，均大于其根结点的值。
- 二叉搜索树的子树也是二叉搜索树。

一棵二叉搜索树长这样：

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6ba6d176e7ec94d2b79fd414a7801a5f.png)

> 这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点

1. 从根结点18开始，因为15小于18，所以从左边开始找。
2. 接着来到10，发现10比15小，所以继续往右边走。
3. 来到15，成功找到。

##### 7.3.2.1 查找

实现代码

1. 加入创建二叉树代码

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int Data;
typedef struct TreeNode {
    Data data;
    struct TreeNode *left;
    struct TreeNode *right;
} *Node;

Node createNode(Data data) {
    Node node = (Node) (malloc(sizeof(struct TreeNode)));
    node->left = node->right = NULL;
    node->data = data;
    return node;
}

int main() {

    return 0;
}
```

2. 插入节点

```c++
Node insert(Node node, Data data) {
    if (node) {
        if (node->data > data) { // 如果插入节点小于当前节点，那么应该放到左边去
            node->left = insert(node->left, data);
        } else if (node->data < data) { // 如果插入节点大于当前节点，那么应该放到右边去
            node->right = insert(node->right, data);
        }
    } else { // 当节点为空时，说明已经找到插入的位置了，创建对应节点
        node = createNode(data);
    }
    return node;
}
```

3. 插入数据

```c++
int main() {
    Node root = insert(NULL, 18);
    insert(root, 10);
    insert(root, 20);
    insert(root,7);
    insert(root,15);
    insert(root,22);
    insert(root,9);
    return 0;
}
```

得到如图所示的二叉树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/84511d104ef02aa82b51ad38938f2781.png)

4. 查找值，按照定义，**大于目标值就向左查找，小于目标值就向右查找**

```c++
Node find(Node root, Data target) {
    while (root) {
        if (root->data > target) {
            root = root->left;
        } else if (root->data < target) {
            root = root->right;
        } else {
            return root;
        }
    }
    return NULL;
}
```

5. 查找最大/最小值，按照定义，**最左边为最小值，最右边为最大值**

```c++
Node findMax(Node root) {
    while (root && root->right) {
        root = root->right;
    }
    return root;
}

Node findMin(Node root) {
    while (root && root->left) {
        root = root->left;
    }
    return root;
}
```



##### 7.3.2.2 删除

最后我们来看看二叉查找树的删除操作，这个操作就比较麻烦了，因为可能会出现下面的几种情况:

1. 要删除的结点是叶子结点。
2. 要删除的结点是只有一个孩子结点。
3. 要删除的结点有两个孩子结点。

首先我们来看第一种情况，这种情况实际上最好办，直接删除就完事了;

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f09c7615d24a32b182b91c2c1aba8fb6.png)

> 而第二种情况，就有点麻烦了，因为有一个孩子，就像一个拖油瓶一样，你离开了还不行,你还得对他负责才可以。当移除后，需要将孩子结点连接上去:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e077ed45cbaec370577c81fcc878fc65.png)

> 可以看到在调整后，依然满足二叉查找树的性质。最后是最麻烦的有两个孩子的情况，这种该怎么办呢?前面只有一个孩子直接上位就完事，但是现在两个孩子，到底谁上位呢?这就不好办了，为了保持二叉查找树的性质，现在有两种选择:

1. 选取其左子树中最大结点上位
2. 选择其右子树中最小结点上位

这里我们以第一种方式为例:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/732a2cc033539768e70a47ee2a708467.png)

编写代码

```c++
Node deleteNode(Node root, Data target) {
    if (root == NULL) {
        return NULL;
    }
    // 左右找
    if (root->data > target) {
        root->left = deleteNode(root->left, target);
    } else if (root->data < target) {
        root->right = deleteNode(root->right,target);
    } else { // 找到要删除的值
        if (root->left && root->right) { // 左右子孩子都有的情况
            // 寻找左子树中最大的值
            Node max = findMax(root->left);
            // 找到后将值替换
            root->data = max->data;
            // 已同样的方式替换其他节点
            root->left = deleteNode(root->left,root->data);
        } else { // 其他两种情况一起处理
            Node tmp = root;
            if (root->right) {
                root = root->right;
            } else {
                root = root->left;
            }
            free(tmp);
        }
    }
    return root; // 返回最终的节点
}
```

测试

```c++
int main() {
    Node root = insert(NULL, 18);
    insert(root, 10);
    insert(root, 20);
    insert(root, 7);
    insert(root, 15);
    insert(root, 22);
    insert(root, 9);

    deleteNode(root, 10);
    return 0;
}
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9e48728958fd9440815efb3f6e661720.png)

#### 7.3.3 平衡二叉树

现在我们依次将下面的值插入到这棵二叉树中:

```
20 15 13 8 6 3
```

在插入完成后,我们会发现这棵二叉树竟然长这样:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/cd1b0f5134f3990c9f73c728e81dc2a2.png)

> 因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。

> 所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/23bf6ce388b0557c7fd6c9aeec86484f.png)

> 所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入**平衡二叉树**的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，**平衡二叉树(AVL树)**就是为了解决这样的问题而生的。

它的性质如下:

- 平衡二叉树一定是一棵二叉查找树。
- 任意结点的左右子树也是一棵平衡二叉树。
- 从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。

可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度减去右子树高度，得到的结果称为该节点的**平衡因子**(Balance Factor) ,比如:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7730a0c127386f33f05571bbe2a170dd.png)

通过计算平衡因子，我们就可以**快速得到是否出现失衡的情况**。比如下面的这棵二叉树，正在执行插入操作:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/be0f20f90928d6f0782217e882e9535c.png)

可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/48934c0ad7b51b79cbbf357e168ff26a.png)

根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡:

1. LL型调整（右旋）

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e7de7df6463b7febbd9ba228e91fa603.png)

首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行**旋转**来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢?对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c9152aa5191fe0bda295ca8edb3a4d42.png)

可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/24d5665c7d15232daa90f068ce2ce940.png)



这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。

**RR型调整**(左旋)

前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/648bc91832d18b89ccb1631b77793b39.png)

操作和上面是一样的，只不过现在反过来了而已:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/26f8b3b29b699966676dae852a137ab2.png)

这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。

**RL型调整**(先右旋，再左旋)

剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样:



#### 7.3.4 红黑树



### 7.4 其他树结构

#### 7.4.1 B树和B+树

#### 7.4.2 哈夫曼树

给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（(Huffman Tree)

带权路径长度达到最小，就是树中所有的叶结点的权值乘上其到根结点根结点的路径长度〈若根结点为0层，叶结点到根结点的路径长度为叶结点的层数)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bbdaa88ad91addc2bd7feb1d0979f016.png)

这里我们分别将叶子结点ABCD都赋予一个权值，我们来尝试计算一下，计算公式如下:
$$
WPL=\sum_{i=1}^{n}(value(i)\times{depth(i)})
$$
那么左右两边的计算结果为:

- 左图:WPL=5×2＋7×2＋2×2＋13×2=54
- 右图:WPL=5×3＋2×3＋7×2+13×1= 48

通过计算结果可知，右图的带权路径长度最小，实际上右图是一棵哈夫曼树。

那么现在给了我们这些带权的叶子结点，我们怎么去构建一颗哈夫曼树呢?首先我们可以将这些结点视为4棵树，他们共同构成了一片森林:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fbe7609eb3e6c242ba270ae67d2bd9dc.png)

首先我们选择两棵权值最小的树作为一颗新的树的左右子树，左右顺序不重要(因为哈夫曼编码不唯一，后面会说)，得到的树根结点权值为这两个结点之和:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/17936c2ac1e33fcc8f510d3e703a1d94.png)

接着，我们需要将这这棵树放回到森林中，重复上面的操作，继续选择两个最小的出来组成一颗新的树，此时得到:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7596dc251aa5468ea8055b7dda480125.png)

继续重复上述操作,直到森林里面只剩下一棵树为止:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7d37c6b3ac1d48bf5ba8098941b44462.png)

这样，我们就得到了一棵哈夫曼树，因为只要保证越大的值越靠近根结点，那么出来的一定是哈夫曼树。所以，我们辛辛苦苦把这棵树构造出来干嘛呢?实际上哈夫曼树的一个比较重要应用就是对数据进行压缩，它是现代压缩算法的基础，我们常常可以看到网上很多文件都是以压缩包（.zip、.7z、.rar等格式)形式存在的，我们将文件压缩之后。

比如这一堆字符串:ABCABCD，现在我们想要将其进行压缩然后保存到硬盘上，此时就可以使用哈夫曼编码。那么怎么对这些数据进行压缩呢?这里我们就可以采用刚刚构建好的哈夫曼树，我们需要先对其进行标注:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d9f661a39e26ed8847ca7934e0667c64.png)

向左走是0，向右走是1，比如现在我们要求出A的哈夫曼编码，那么就是根结点到A整条路径上的值拼接:

- A:110
- B:0
- C: 111
- D:10

这些编码看起来就像二进制的一样，也便于我们计算机的数据传输和保存，现在我们要对上面的这个字符串进行压缩，那么只需要将其中的每一个字符翻译为对应编码就行了:

- ABCABCD=110 0 111 110 0 111 10

这样我们就得到了一堆压缩之后的数据了。那怎么解码回去呢，也很简单，只需要对照着写回去就行了:

- 110 0 111 110 0 111 10 = ABCABCD

我们来尝试编写一下代码实现一下哈夫曼树的构建和哈夫曼编码的获取把，因为构建哈夫曼树需要选取最小的两个结点，这里需要使用到优先级队列。

优先级队列与普通队列不同，它允许VIP插队（权值越方的元素优先排到前面去)，当然出队还是一律从队首出来。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/75e4c77138ffe3533902d440861853f7.png)

比如一开始4和9排在队列中，这时又来了个7，那么由于7比4大，所以说可以插队，直接排到4的前面去，但是由于9比7大，所以说不能再往前插队了

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/338ae345dc9675c8b315aaf3a9ad9705.png)



这就是优先级队列，VIP插队机制，要实现这样的优先级队列，我们不用实现，直接用C++的`priority_queue`即可

1. 定义二叉树结构体和比较结构体和初始化二叉树函数

```c++
typedef int T;
typedef struct TreeNode {
    T data;
    struct TreeNode *left;
    struct TreeNode *right;
    int value; // 权值
} *Node;
// 比较结构体
struct compare {
    bool operator()(const Node a, const Node b) const {
        return a->value < b->value;
    }
};
Node createNode(T data, int value) {
    Node node = (Node) malloc(sizeof(struct TreeNode));
    node->data = data;
    node->value = value;
    node->left = node->right = NULL;
    return node;
}
```

2. 定义优先队列`priority_queue`，向里面插入数据

```c++
priority_queue<Node, vector<Node>, compare> queue;

Node node1 = createNode('A', 5);
Node node2 = createNode('B', 29);
Node node3 = createNode('C', 7);
Node node4 = createNode('D', 8);
Node node5 = createNode('E', 14);

queue.push(node1);
queue.push(node2);
queue.push(node3);
queue.push(node4);
queue.push(node5);

while (!queue.empty()) {
    Node node = queue.top();
    printf("%c %d\n", node->data, node->value);
    queue.pop();
}
```

3. 创建一个哈夫曼树

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7d37c6b3ac1d48bf5ba8098941b44462.png)

```c++
Node buildHuffmanTree(priority_queue<Node, vector<Node>, compare> &queue) {
    while (queue.size() > 1) {
        Node left = queue.top();
        queue.pop();
        Node right = queue.top();
        queue.pop();
        Node parent = createNode(' ', left->value + right->value);
        parent->left = left;
        parent->right = right;
        queue.push(parent);
    }
    return queue.top();
}
```

4. 进行编码，向左的路径为0，向右的路径为1

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d9f661a39e26ed8847ca7934e0667c64.png)

```c++
char *encode(Node root, T e) {
    if (root == NULL) return NULL;
    if (root->data == e) return "";
    char *str = encode(root->left, e);
    char *s = static_cast<char *>(malloc(sizeof(char) * 10));
    memset(s, 0, sizeof(char) * 10); // 注意申请的内存可能不干净，需要清空
    if (str != NULL) {
        s[0] = '0';
        str = strcat(s, str);
    } else {
        str = encode(root->right, e);
        if (str != NULL) {
            s[0] = '1';
            str = strcat(s, str);
        }
    }
    return str;
}
// 打印一下
void print(Node root, T e) {
    printf("%c的编码: %s\n", e, encode(root, e));
}
```

5. 最后调用一下

```c++
int main() {
    priority_queue<Node, vector<Node>, compare> queue;

    Node node1 = createNode('A', 5);
    Node node2 = createNode('B', 16);
    Node node3 = createNode('C', 8);
    Node node4 = createNode('D', 13);

    queue.push(node1);
    queue.push(node2);
    queue.push(node3);
    queue.push(node4);

    Node root = buildHuffmanTree(queue);
    print(root, 'A');
    print(root, 'B');
    print(root, 'C');
    print(root, 'D');

    return 0;
}
```

#### 7.4.3 堆和优先级队列

**堆**（Heap）首先必须是一棵完全二叉树，树中父亲都比孩子小的我们称为**小根堆**（小顶堆），树中父亲都比孩子大则是**大根堆**（注意不要跟二叉查找树搞混了，二叉查找树是左小右大，而堆只要是孩子一定小或者大)，它是一颗具有特殊性质的完全二叉树。比如下面就是一个典型的大根堆:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bb654385b465ecf1f9aa7afd657e28be.png)

因为完全二叉树比较适合使用数组才存储(因为是按序的）所以说一般堆都是以数组形式存放:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f13bd6fe2fb9a92a62ce32768c1ac4a8.png)

那么它是怎么运作的呢?比如现在我们想要往堆中插入一个新的元素8，那么∶

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0faf737ecba7aafe3fed62843fa366dc.png)

因为是一棵完全二叉树，那么必须按照顺序，继续在当前这一行从左往右插入新的结点，其实就相当于在数组的后面继续加一个新的进来，是一样的。但是因为要满足大顶堆的性质，所以此时8加入之后，破坏了规则，我们需要进行对应的调整（堆化)，很简单，我们只需要将其与父结点交换即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e4fcf9e520ee7d4e283338ffd3e68ef1.png)

同样的，数组的形式的话，我们就行先计算出它的父结点，然后进行交换即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5091d3320568c6b38386e379d4bd4a1e.png)

当然，还没完，我们还需要继续向上比较，直到稳定为止，此时7依然是小于8的，所以说需要继续交换:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f65e2d897cd27fb2caefdd8cfded9598.png)

现在满足性质了，堆化结束，可以看到最大的元素被排到了最前面，这不就是我们前面的优先级队列吗。

现在我们来试试看删除队首元素，也就相当于出队操作，删除最顶上的元素:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/23214b5c3386e8e6b0c4fdfb58faf794.png)

现在需要删除最顶上的元素但是我们需要保证删除之后依然是一棵完全二叉树，所以说我们先把排在最后面的拿上来顶替一下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c2718a8ab4f40cb5ce11bb5e6d58b4cc.png)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6efeb79c00d44a54a86281684a9c85d6.png)

接着我们需要按照与插入相反的方向，从上往下进行堆化操作，规则是一样的，遇到大的就交换，直到不是为止:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4070714ad6ae89026bfa18831b7913b6.png)

这样，我们发现，即使完成了出队操作，依然是最大的元素排在队首，并且整棵树依然是一棵完全二叉树。

按照上面的操作，我们来编写一下代码吧，这里还是以大顶堆为例:

1. 定义大顶堆结构体、初始化函数、打印函数

```c++
typedef int T;
typedef struct MaxHeap {
    T *arr;
    int size;
    int capacity;
} *Heap;

bool initHeap(Heap heap) {
    heap->size = 0;
    heap->capacity = 10;
    heap->arr = static_cast<T *>(malloc(sizeof(T) * heap->capacity));
    return heap->arr != NULL;
}

void print(Heap heap) {
    for (int i = 1; i <= heap->size; i++) {
        printf("%d ", heap->arr[i]);
    }
    printf("\n");
}
```

2. 插入函数

```c++
bool insert(Heap heap, T e) {
    if (heap->size == heap->capacity) return false;
    int index = ++heap->size; // 先计算出插入位置，因为是从1开始的，所有要先自增
    // 然后开始向上堆化，直到符合为止
    while (index > 1 && e > heap->arr[index / 2]) {
        heap->arr[index] = heap->arr[index / 2];
        index /= 2;
    }
    // 现在得到的index就是最终位置
    heap->arr[index] = e;
    return true;
}
```

3. 删除函数

```c++
T del(Heap heap) {
    T max = heap->arr[1], e = heap->arr[heap->size--];
    int index = 1;
    while (index * 2 <= heap->size) {
        int child = index * 2; // 先找到左孩子
        // 看看右孩子和左孩子哪个大，先选一个大的出来
        if (child < heap->size && heap->arr[child] < heap->arr[child + 1]) {
            child++;
        }
        if (e >= heap->arr[child]) break; // 如果子节点都不大于新节点，那么说明就是这个位置了
        else heap->arr[index] = heap->arr[child]; // 否则就把子节点上移
        index = child; // 然后继续向下堆化
    }
    heap->arr[index] = e; // 找到合适的位置，放进去就可以了
    return max;
}

int main() {
    struct MaxHeap heap;
    initHeap(&heap);

    insert(&heap, 5);
    insert(&heap, 2);
    insert(&heap, 3);
    insert(&heap, 7);
    insert(&heap, 6);

    for (int i = 0; i < 5; i++) {
        printf("%d ", del(&heap));
    }

}
```



### 7.5 算法实战

#### 7.5.1 二叉搜索树的范围和

LeetCode: 938. 二叉搜索树的范围和

> 给定二叉搜索树的根结点root，返回值位于范围[low, high]之间的所有结点的值的和。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9e563d8df1d1fe0248aed017f17293fe.png)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9a48466494d44b0e22117dd8b0c214bd.png)

代码

```c++
int rangeSumBST(Tree root, int low, int high) {
    if (root == NULL) return NULL;
    if (root->data < low) return rangeSumBST(root->right, low, high);
    if (root->data > high) return rangeSumBST(root->left, low, high);
    return root->data + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
}
```

#### 7.5.2 重建二叉树

LeetCode： 剑指Offer 07.重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bce5baf97a561ca8a0d7ba580afc1bfd.png)

在中序遍历序列中找到根节点的位置后，这个问题就很好解决了，大致思路如下:

1. 由于前序遍历首元素为根节点值，首先可以得到根节点值。
2. 在中序遍历序列中通过根节点的值，寻找根节点的位置。
3. 将左右两边的序列分割开来，并重构为根节点的左右子树。(递归分治)
4. 在新的序列中，重复上述步骤，通过前序遍历再次找到当前于树的根节点，再次进行分割。
5. 直到分割到仅剩下一个结点时，开始回溯，从而完成整棵二叉树的重建。





## 8. 散列表

我们之前认识的查找算法，最快可以达到对数阶$O(logN)$，那么我们能否追求极致，让查找性能突破到常数阶呢?这里就要介绍到我们的**散列**（也可以叫哈希Hash）)它采用直接寻址的方式，在理想情况下，查找的时间复杂度可以达到常数阶$O(1)$。

### 8.1 散列查找

**散列**(Hashing)通过**散列函数**（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表)，也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b69cf893e8251cd695741b1f8e4fec6c.png)

#### 8.1.1 散列函数

**散列函数**也叫**哈希函数**，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后,会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5471e6b08137f293c955fe161f172895.png)

显示

```
e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf
```

这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢?我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。



## 9. 图结构

图也是由多个结点连接而成的，但是一个结点可以同时连接多个其他结点，多个结点也可以同时指向一个结点，跟我们之前讲解的树结构不同，它是一种多对多的关系:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/20823465864aa4cc83189b65ee3556f7.png)

它比树形结构更加复杂，没有明确的层次关系，结点与结点之间的连接关系更加自由，图结构是**任意两个数据对象之间都有可能存在某种特定关系的数据结构**。



### 9.1 基本概念

**图**（Graph）一般由两个集合共同构成，一个是非空但是有限的顶点集合$V$（Vertex） ，另一个是描述顶点之间连接关系的边集合$E$（Edge，边集合可以为空集，比如只有一个顶点的情况下），一个图实际上正是由这些结点（顶点）和对应的边组成的。因此，图可以表示为:$G=(V,E)$

比如一个图我们可以表示为，集合$V=\{A,B,C,D,B\}$，集合$E=\{(A,B),(B,C),(C,D),(D,A),(C,A)\}$，图有两种基本形式，一种是上面那样的**有向图**（有向图表明了方向，从哪个点到哪个点)，还有一种是**无向图**（无向图仅仅是连接，并不指明方向），比如我们上面这样表示就是一个无向图:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/71855a3440762c3afea13cb79114bfe0.png)

每个结点的**度（$d_G(v)$）**就是与其连接的边数，每条边是可以包含权值的，当前也可以不包含。

当然我们也可以将其表示为有向图，集合$V=\{A,B,C,D\}$，集合$E=\{<A,B>,<B,C>,<C,D >,<D,A >,<C,A>\}$注意有向图的边使用尖括号$<>$表示。比如上面这个有向图，那么就长这样:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/80e1cc15ec13d753e6e99dc97389ebc0.png)

如果是无向图的一条边$(A,B)$，那么就称$A$、$B$互为邻接点；如果是有向图的一条边$<A,B>$,那么就称起点A邻接到终点B。有向图的每个结点分为**入度**和**出度**，其中**入度就是与顶点相连且指向该顶点的边的个数，出度就是从该顶点指向邻接顶点的边的个数**。)

只要我们的图中不出现**自回路边**或是**重边**，那么我们就可以称这个图为**简单图**，比如上面两张图都是简单图。而下面的则是典型的非简单图了，其中图一出现了自回路，而图二出现了重边:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8ffa661fc2b937c06434f3e03ac49a60.png)

如果在一个无向图中，**任意两个顶点都有一条边相连**，则称该图为**无向完全图**:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/45c952817e7195ee1dd9db92fccef5a3.png)

同样的，在一个有向图中，如果**任意两顶点之间都有由方向互为相反的两条边连接**，则称该图为**有向完全图**，具有n个顶点的有向图的边数为$n\times(n-1)$:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6eddf83fe12b4ed3f1fbe7aa8547d76a.png)

图通过边将顶点相连，这样我们就可以从一个顶点经过某条路径到达其他顶点了，比如我们现在想要从下面的V5点到达V1点:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/70c8db48aa47c23fe73f045bd1015f3b.png)

那么我们可以有很多种路线，比如经过V2到达，经过V3到达等:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1629b7a778a97b3ac12b5d575b6026a5.png)

在一个无向图中，如果从一个顶点到另一个顶点有路径，那么就称这两个顶点是连通的。可以看到，要从V5到达V1我们可以有很多种选择，从N5可以到达V1(当然也可以反着来)，所以，我们称V5和V1连通的。特别的，如果图中**任意两点都是连通的**，那么我们就称这个图为**连通图**。对于有向图，如果图中**任意顶点A和B，既有从A到B的路径，也有B到A的路径**，则称该有向图是**强连通图**。

对于图$G=(V,B)$和$G'=(V',E')$，若满足$V'$是$V$的子集，并且$E'$是$E$的子集，则称$G'$是$G$的**子图**，比如下面的两个图:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/deb43928f004e5756a5af3818bda872c.png)

其中右边的图就满足上述性质，所以说右边的图是左边图的子图。

无向图的极大连通子图称为**连通分量**，有向图的极大连通子图称为**强连通分量**。那么什么是极大连通子图呢?首先连通子图就是原图的子图，并且子图也是连通图，同时应该具有最大的顶点数，即再加入原图中的其他顶点会导致子图不连通，拥有极大顶点数的同时也要包含依附于这点顶点所有的边才行，比如:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/09a93860230adce1d5667a171a19cb1b.png)

可以看到右侧图1、2、3都是左图的子图，但是它们并不都是原图的连通分量，首先我们来看图1，它也是一个连通图，并且包含极大顶点数和所有的边(也就是原图内部的这一块)所以说它是连通分量，我们接着来看图2，它虽然也是连通图，但是并没有包含极大顶点数(最多可以吧D也给加上，但是这里没加）所以说并不是。最后来看图3，它也是连通图，并且包含了极大顶点数和边，所以说是连通分量。

**带权值的图**

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c50b2ec3ba815edbc0dc1a9786cf38f1.png)

可以使用邻接矩阵表示
$$
\begin{bmatrix}
0 & 10 & 30 & +\infty & 20 \\
10 & 0 & 40 & 50 & +\infty \\
+\infty & +\infty & 50 & 0 & 60 \\
20 & +\infty & +\infty & 60 & 0
\end{bmatrix}
$$
其中，数字表示到两个点之前的权值，$+\infty$表示两dian无法到达



### 9.2 存储结构

#### 9.2.1 邻接矩阵

邻接矩阵实际上就是用矩阵去表示图中各顶点之间的邻接关系和权值。假设有一个图$G=(V,E)$，其中有N个顶点，那么我们就可以使用一个NxN的矩阵来表示，比如下面有A、B、C、D四个顶点的图:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a94f22b0520106564561d3946551700e.png)

此时我们需要使用邻接矩阵来表示它，就像下面这样:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a874f0d954f5038ed12cb8aa9b7a1dd7.png)

对于一个不带权值的图来说:
$$
G_{ij}=
\begin{equation}
\begin{cases}
1,无向图的(v_i,v_j)或有向图的<v_i,v_j>是图中的边\\
0,无向图的(v_i,v_j)或有向图的<v_i,v_j>不是图中的边
\end{cases}
\end{equation}
$$
对于一个带权值的图来说，如果有边，则直接填写对应边的权值，如果没有，那么就填写0或是$\infty$(因为某些图会认为0也是权值，所以说可以用$\infty$，它可以是一个计算机允许的最大值大于所有边的权值的数）来进行表示:
$$
G_{ij}=
\begin{equation}
\begin{cases}
\omega_{ij},无向图的(v_i,v_j)或有向图的<v_i,v_j>是图中的边\\
0或\infty,无向图的(v_i,v_j)或有向图的<v_i,v_j>不是图中的边
\end{cases}
\end{equation}
$$
所以说，对于上面的有向图，我们应该像这样填写:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3ce5b752a502c9d41469db6774415e44.png)

那么我们来看看无向图的邻接矩阵呢?比如下面的这个图:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/593a1fea8af4b930bca825213f658d16.png)

对于无向图来说，一条边两边是相互连接的，所以说，A连接B，那么B也连接A，所以说就像这样:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3688590e72c4bb37cf34923462ac48b8.png)

可以看到得到的矩阵用我们在《线性代数》中的定义来说就是一个对称矩阵（上半和下半都是一样的因为没有自回路顶点，所以说主对角线上的元素全都是0。由于无向图没有方向之分，顶点之间是相互连接的，所以说无向图的邻接矩阵必定是一个对称矩阵。

我们可以来总结一下性质:

- 无向图的邻接矩阵一定是一个对称矩阵，因此，有时为了节省时间，我们可以只存放上半部分。
- 对于无向图，邻接矩阵的第i行非0(或非$\infty$)的个数就是第i个顶点的度。
- 对于有向图，邻接矩阵的第i行非0(或非$\infty$)的个数就是第i个顶点的出度（纵向就是入度了）

**代码实现**

1. 创建邻接矩阵图

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define MaxVertex 5

typedef char Data;
typedef struct MatrixGraph {
    int vertexCount, edgeCount;
    int matrix[MaxVertex][MaxVertex]; // 邻接矩阵
    Data data[MaxVertex]; // 各个顶点对应的数据
} *Graph;

Graph createGraph() {
    Graph graph = (Graph) malloc(sizeof(struct MatrixGraph));
    graph->vertexCount = graph->edgeCount = 0;
    memset(graph->matrix, 0, sizeof(graph->matrix));
    return graph;
}
```

2. 插入顶点和边

```c++
/**
 * 添加顶点
 * @param graph 图
 * @param data 数据
 */
void addVertex(Graph graph, Data data) {
    if (graph->vertexCount >= MaxVertex) {
        return;
    }
    graph->data[graph->vertexCount++] = data;
}

/**
 * 添加边
 * @param graph 图
 * @param a 起始顶点下标
 * @param b 目标顶点下标
 */
void addEdge(Graph graph, int a, int b) {
    if (graph->matrix[a][b] == 0) {
        graph->matrix[a][b] = 1; // 如果是无向图的话，需要[a][b]和[b][a]都置为1
        graph->edgeCount++;
    }
}

int main() {
    Graph graph = createGraph();
    for (char c = 'A'; c <= 'D'; ++c) {
        addVertex(graph, c);
    }

    addEdge(graph, 0, 1); // A->B
    addEdge(graph, 1, 2); // B->C
    addEdge(graph, 2, 3); // C->D
    addEdge(graph, 3, 0); // D->A
    addEdge(graph, 2, 0); // C->A
    
    return 0;
}
```

3. 打印邻接矩阵

```c++
/**
 * 打印图结构
 * @param graph 图
 */
void printGraph(Graph graph) {
    for (int i = -1; i < graph->vertexCount; ++i) {
        for (int j = -1; j < graph->vertexCount; ++j) {
            if (j == -1) {
                printf("%c", 'A' + i);
            } else if (i == -1) {
                printf("%3c", 'A' + j);
            } else {
                printf("%3d", graph->matrix[i][j]);
            }
        }
        printf("\n");
    }
}
```

4. 打印结果

```
@  A  B  C  D
A  0  1  0  0
B  0  0  1  0
C  1  0  0  1
D  1  0  0  0
```



#### 9.2.2 邻接表

我们可以使用邻接矩阵在程序中保存一个图的边相关信息，它采用二维数组的形式，将对应边的连接关系进行存储，但是我们知道，数组存在容量上的局限性。同时，我们创建邻接矩阵后，如果图的边数较多（稠密图）利用率还是挺高的，但是一旦遇到边数很少的图（稀疏图）那么表中大量的位置实际上都是0，根本没有被利用起来，是很浪费的。

此时，我们可以考虑使用**链式结构**来解决这种问题，就像下面这样:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/142a37a8bc1e454b12a34ae07446599d.png)

对于图中的每个顶点，建立一个数组，存放一个头结点，我们将与其邻接的顶点，通过一个链表进行记录（看着挺像前面讲的哈希表）这样，也可以表示一个图的连接关系，并且内存空间能够得到更加有效的利用。当然，对于无向图来说，跟之前一样，两边都需要进行保存:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7931554d6b665cd86442c969c1ef2bcb.png)

**代码实现**

1. 创建邻接表

```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxVertex 5
typedef char Data;

typedef struct Node { // 节点和头节点分开定义，普通节点记录邻接顶点信息
    int nextVertex;
    struct NodeList *next;
} *Node;

struct HeadNode { // 头节点记录元素
    Data data;
    struct Node *next;
};

typedef struct AdjacencyGraph {
    int vertexCount; // 顶点数
    int edgeCount; // 边数
    struct HeadNode vertex[MaxVertex];
} *Graph;

Graph createGraph() {
    Graph graph = (Graph) malloc(sizeof(struct AdjacencyGraph));
    graph->vertexCount = graph->edgeCount = 0;
    return graph;
}
```

2. 插入顶点和边

```c++
/**
 * 添加顶点
 * @param graph 图
 * @param data 数据
 */
void addVertex(Graph graph, Data data) {
    graph->vertex[graph->vertexCount].data = data;
    graph->vertex[graph->vertexCount].next = NULL;
    graph->vertexCount++;
}

/**
 * 添加边
 * @param graph 图
 * @param a 起始顶点下标
 * @param b 目标顶点下标
 */
void addEdge(Graph graph, int a, int b) {
    Node node = graph->vertex[a].next;
    Node newNode = malloc(sizeof(struct Node));
    newNode->next = NULL;
    newNode->nextVertex = b;
    if (!node) { // 如果头节点下 一个都没有，直接连上去
        graph->vertex[a].next = newNode;
    } else { // 否则说明当前顶点已经连接了至少一个其他顶点，有可能出现已经连接过的情况，所有要特殊处理一下
        do {
            if (node->nextVertex == b) { // 如果已经连接了对应节点，直接返回
                return;
            } else if (node->next) { // 否则继续向后遍历
                node = node->next;
            } else { // 如果没有下一个了，那么说明找到最后一个节点了，直接结束
                break;
            }
        } while (1);
        node->next = newNode;
    }
    graph->edgeCount++;
}

int main() {
    Graph graph = createGraph();
    for (char c = 'A'; c <= 'D'; ++c) {
        addVertex(graph,c);
    }
    addEdge(graph, 0, 1); // A->B
    addEdge(graph, 1, 2); // B->C
    addEdge(graph, 2, 3); // C->D
    addEdge(graph, 3, 0); // D->A
    addEdge(graph, 2, 0); // C->A
}
```

3. 遍历邻接表

```c++
/**
 * 打印图结构
 * @param graph 图
 */
void printGraph(Graph graph) {
    for (int i = 0; i < graph->vertexCount; ++i) {
        printf("%d | %c", i, graph->vertex[i].data);
        Node node = graph->vertex[i].next;
        while (node) {
            printf(" -> %d", node->nextVertex);
            node = node->next;
        }
        printf("\n");
    }
}
```

得到结果如图，结果符合预期

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f3664b58a691a942571d0b1388800f7a.png)

不过虽然这样的方式看上去更加的简单高效，但是会给我们带来一些不必要的麻烦，比如上面创建的领接表，我们只能快速得到某个顶点指向了哪些顶点，也就是只能计算到顶点的出度，但是无法快速计算顶点的入度，只能将所有结点统计之后才能得到入度。所以说在**表示有向图时，查找上并没有邻接矩阵来的方便**。

为了解决这种问题，我们可以建立一个**逆邻接表**，来表示所有指向当前顶点的顶点列表:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e94c07acee418c3c2f36c8f7a5e65efa.png)

实际上就是反着来而已，通过建立这两个邻接表，就能在一定程度上缓解不方便的情况。

**图练习题**

1. 在一个具有n个顶点的有向图中，若所有顶点的出度之和为s，则所有顶点的入度数之和为?

​			A: s			B: s-1			C: s+1 			D: 2s

> 有向图的所有出度实际上就是所有顶点连向其他顶点的边数，对于单个顶点来说，要么是自己指向别人（**自己的出度，别人的入度**），要么别人指向自己（**别人的出度，自己的入度**），这东西就是个相对的而已，而这些都可以一律看做出度，所以说所有顶点入度数之和就是所有顶点出度之和，所以选A

2. 在一个具有n个顶点的无向完全图中，所含的边数为?

​			A: n		B: n(n-1)		C: n(n-1)/2		D: n(n+1)/2

> 首先回顾一下无向完全图的定义︰在一个无向图中，任意两个顶点都有一条边相连，则称该图为无向完全图。既然任意两个顶点都有一个，那么每个结点都会有$n-1$条与其连接的边，所以说总数为$n\times(n-1)$但是由于是无向图，没有方向之分，所以说需要去掉一半的数量，得到$\frac{n\times(n-1)}{2}$，选择C

3. 若要把n个顶点连接为一个连通图，则至少需要几条边?

​			A: n		B: n -1		C: n+1		D: 2n

> 连通图的定义是，**每个顶点至少有一条到达其他顶点的路径**，所以说我们只需要找一个最简单能够保证每个结点都有与其相连的就行了，也就是连成—根直线（或者是树）的情况，选择B

4. 对于一个具有n个顶点和e条边的无向图，在其对应的邻接表中，所含边结点有多少个?

​			A: n		B: ne		C: e		D: 2e

> **对于无向图，节点个数等于边数的两倍，对于有向图，刚好等于边数**，所以说选择D



### 9.3 图的遍历

对于迷宫游戏，人脑是怎么去寻找正确的路径？

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/275dc21f25fce6a9715e01c8ca71d779.png)

我们首先还是会从起点开始看，我们会尝试去走分叉路的每一个方向，如果遇到死胡同，那么我们就退回到上一个路口（回溯），再去尝试其他方向，直到能一直往下走为止。经过不断重复上述的操作，最后我们就肯定能够到达迷宫的出口了

而图的搜索，实际上也是类似于迷宫这样的形式，我们需要从图的某一个顶点出发，去寻找到图中对应顶点的位置，这一部分，我们将对图的搜索算法进行讨论。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0e19224df2d83f78efd84e1062e7fb4c.png)

#### 9.3.1 深度优先搜索（DFS）

我们之前在学习二叉树的过程中，讲解了树的前序遍历，各位回想一下，我们当时是如何在进行遍历的?

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ff26915f1a0fc45fafc505b6f5c397b3.png)

前序遍历就是勇往直前，直接走到底，然后再回去走其他的分支，而我们的图其实也可以像这样，我们可以一路向前，如果到了死胡同，那么就倒回去再走其他的方向，如果所有方向都走不通，继续再回到上一个路口（实际上就是我们人脑的思维）这样不断的寻找，肯定是可以找到的。

比如现在我们要从A开始寻找下图中的I:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5b426f4c82e6e6a038f70be1930aabcf.png)

那么我们的路线可以是这样的:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f3c23fd0d0789c47f308b4d15dd13c2a.png)

此时顶点B有三个方向，那么我们可以先随便选一个方向（当然，一般情况下为了规范，推荐按照字母排列顺序来走，这里为了演示，就随便走了)看看:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c4a1c466bbbe6fb3d834106aff1466d8.png)

此时来到K，我们发现K已经是一个死胡同，没有其他路了，那么此时我们就需要回到上一个路口，继续去探索其他的路径:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c971958d6b4d78c90f9534635abe6ec6.png)

此时我们接着往下一个相邻的顶点G走，发现G有其他的分叉，那么我们就继续向前:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0627f246354da90501b296b85a34d0df.png)

此时走到F发现又是死路，那么退回到G，走其他的方向:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f71cd034611a66cc332854b4eeb442a6.png)

运气太垃了，又到死胡同了，同样的，回到G继续走其他方向:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/96b2b1212d2c2022cefcd35b432061e0.png)

走到C之后，我们有其他的路，我们继续往后走:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a08ee608a1bc193eb135ffa72d75791f.png)

此时走到顶点H，发现H只有一条路，并且H再向前是已经走过的顶点B，那么此时不能再向前了，所以说直接退回到C，走另一边

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1cfdca9dc595986596e95a73e5b9566f.png)

此时来到E，又有两条路，那么继续随便选一条走:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/273aecaadbb4b98ceb1191809ca74258.png)

此时来到顶点J，发现又是死胡同，退回到E,继续走另一边:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/78819ecdb89376e3142eab3979024c95.png)

好了，经过了这么多试错，终于是找到了I顶点，这种方式就是**深度优先搜索**了。

**代码实现**

这里使用一个简单的图

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5e53915fd987921d521b2a88209cdfb8.png)

这里我们使用**邻接表**表示图，因为邻接表直接保存相邻顶点，所以说到达顶点时遍历相邻顶点会更快（能够到达$O(V+E)$线性阶)而如果使用邻接矩阵的话，我们得完整遍历整个二维数组，就比较费时间了(需要$O(V^2)$平方阶)

比如现在我们想从A开始查找顶点F，首先先把图给建好（注意有6个顶点，记得容量写好)∶

1. 使用上面编写的邻接表代码，注意修改`MaxVertex`，添加顶点

```c++
int main() {
    Graph graph = createGraph();
    for (char c = 'A'; c <= 'F'; ++c) {
        addVertex(graph,c);
    }
    addEdge(graph, 0, 1); // A->B
    addEdge(graph, 1, 2); // B->C
    addEdge(graph, 1, 3); // B->D
    addEdge(graph, 1, 4); // B->E
    addEdge(graph, 4, 5); // E->F

    printGraph(graph);
}
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/05e71ef38dd1bb2a908ef699187671ad.png)

2. 然后就是深度优先搜索算法

```c++
/**
 * 深度优先搜索
 * @param graph 图
 * @param startVertex 起点顶点下标
 * @param targetVertex 目标顶点下标
 * @param visited 搜索过的顶点数组
 */
void dfs(Graph graph, int startVertex, int targetVertex, int *visited) {
    if (startVertex == targetVertex) {
        printf("%c", graph->vertex[startVertex].data); // 打印顶点
        return;
    }
    printf("%c -> ", graph->vertex[startVertex].data); // 打印顶点
    visited[startVertex] = 1; // 标记当前顶点已经走过了
    Node node = graph->vertex[startVertex].next; // 往下一个顶点走
    while (node) {
        if (!visited[node->nextVertex]) { // 下一个顶点没有访问过才进行下一步
            dfs(graph, node->nextVertex, targetVertex, visited);
        }
        // 走到底（NULL）没有走到目标节点，回溯到起始位置（路口），选择下一个顶点继续
        node = node->next; // 继续下一个节点
    }
}
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/28b6b1b025137d487192a534d4ae01f5.png)

路线如图

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1adc7cd8f60e7133a9909530ca089a09.png)

3. 现在我们需要查对找的顶点进行判断

```c++
/**
 * 深度优先搜索
 * @param graph 图
 * @param startVertex 起点顶点下标
 * @param targetVertex 目标顶点下标
 * @param visited 搜索过的顶点数组
 * @return _Bool 是否找到目标点
 */
_Bool dfs(Graph graph, int startVertex, int targetVertex, int *visited) {
    if (startVertex == targetVertex) {
        printf("%c", graph->vertex[startVertex].data); // 打印顶点
        return 1;
    }
    printf("%c -> ", graph->vertex[startVertex].data); // 打印顶点
    visited[startVertex] = 1; // 标记当前顶点已经走过了
    Node node = graph->vertex[startVertex].next; // 往下一个顶点走
    while (node) {
        if (!visited[node->nextVertex]) { // 下一个顶点没有访问过才进行下一步
            if (dfs(graph, node->nextVertex, targetVertex, visited)) {
                return 1;
            }
        }
        // 走到底（NULL）没有走到目标节点，回溯到起始位置（路口），选择下一个顶点继续
        node = node->next; // 继续下一个节点
    }
    return 0;
}
```

得到结果

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/3d422c0e96cab84772a5a16e149d6c5a.png)

那么要是去寻找一个没有连接到图中的结点呢?

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5c20684e94150f56adf92df56100aebd.png)



#### 9.3.2 广度优先搜索（BFS）

前面我们介绍了深度优先搜索，我们接着来看另一种方案。还记得我们在前面二叉树中学习的层序遍历吗?

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7909e5447cb61457e617a363bef2312f.png)

层序遍历实际上是优先将每一层进行遍历，而不是像前序遍历那样勇往直前，而图的搜索其实也可以采用这种方案，我们可以先探索顶点所有的分支，然后再依次去看这些分支的所有分支:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e0c59dae628b85dac0caa414d1911d94.png)

首先咱还是从A来到B，此时B有三条分叉路，我们依次访问这三条路的各个顶点:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f0a893360a8b0ba08c6e25d611e5f391.png)

我们先记录一下这三个顶点，同样需要使用队列来完成:H、G、K

注意访问之后不要再继续向下了，接着我们从这三个里面的第一个顶点H开始，按照同样的方法继续:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8116b69b0879fa62bdb6d4a03b5b290a.png)

此时因为只有一个分支，所以说找到C，继续记录，将C也添加进去:G、K、C
注意此时需要回去，继续看之前三个顶点的第二个顶点G:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/35d199dbf22d5d89ea893705d19b1739.png)

此时C已经看过了，接着就找到了F和D，也是记录一下: K、C、F、D
然后，我们继续看之前三个结点的最后一个:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bad897e602d0f7c8779c5b5ce4b130f0.png)

此时K已经是死胡同了，那么就结束，然后继续看下一个C:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f81b829a2e79cc162a7b73330488b405.png)

此时继续将E给记录进去:F、D、E，接着看D和F，也没有后续了，那么最后就只有E了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1d6b12b0233c7e84fe89a9de95ce6d16.png)

 **代码实现**

由于使用了队列，这里使用的是之前写的队列代码

1. 队列代码

```c++
// ---------------------- / 队列定义 / ----------------------------------
typedef struct QNode {
    QData data;
    struct Queue *next;
} *QNode;

typedef struct Queue {
    QNode front;
    QNode rear;
} *Queue;

/**
 * 创建队列
 * @return 返回创建的队列
 */
Queue createQueue() {
    QNode node = malloc(sizeof(struct QNode)); // 头节点不存数据
    if (node == NULL) {
        return NULL;
    }
    Queue queue = malloc(sizeof(struct Queue));
    if (queue == NULL) {
        return NULL;
    }
    queue->front = queue->rear = node;
    return queue;
}

/**
 * 入队
 * @param queue 队列
 * @param data 数据
 * @return 成功返回1 失败返回0
 */
_Bool offerQueue(Queue queue, QData data) {
    QNode node = malloc(sizeof(struct QNode));
    if (node == NULL) {
        return 0;
    }
    node->data = data;
    queue->rear->next = (Queue) node;
    queue->rear = node;
    queue->rear->next = NULL;
    return 1;
}

_Bool isEmpty(Queue queue) {
    return queue->front == queue->rear;
}

/**
 * 出队
 * @param queue 队列
 * @return 队列元素
 */
QData pollQueue(Queue queue) {
    if (isEmpty(queue)) {
        return INT_MAX;
    }
    QNode node = (QNode) queue->front->next;
    QData data = node->data;
    queue->front->next = node->next;
    if (queue->rear == node) {
        queue->rear = queue->front;
    }
    free(node);
    return data;
}

/**
 * 打印队列
 * @param queue
 */
void printQueue(Queue queue) {
    printf("<<< ");
    QNode node = (QNode) queue->front->next;
    while (node != NULL) {
        printf("%d ", node->data);
        node = (QNode) node->next;
    }
    printf(">>>\n");
}
```

图使用的是上面的图

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5e53915fd987921d521b2a88209cdfb8.png)

2. 广度优先搜索

```c++
/**
 * 广度优先搜索
 * @param graph 图
 * @param startVertex 起始顶点下标
 * @param targetVertex 目标顶点下标
 * @param visited 已到达过的顶点数组
 * @param queue 辅助数组
 */

void bfs(Graph graph, int startVertex, int targetVertex, int *visited, Queue queue) {
    offerQueue(queue, startVertex);
    visited[startVertex] = 1;
    while (!isEmpty(queue)) {
        int next = pollQueue(queue);
        printf("%c -> ", graph->vertex[next].data);
        GNode node = graph->vertex[next].next;
        while (node) {
            if (node->nextVertex == targetVertex) {
            	printf("%c", graph->vertex[next].data);
            	return;
        	}
            if (!visited[node->nextVertex]) { // 如果没有走过，直接入队
                offerQueue(queue, node->nextVertex);
                visited[node->nextVertex] = 1; // 入队时设定为1
            }
            node = (GNode) node->next;
        }
    }
}
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5542f3c2acb0c03d511b7570ba391d5e.png)

加上结果返回值

```c++

/**
 * 广度优先搜索
 * @param graph 图
 * @param startVertex 起始顶点下标
 * @param targetVertex 目标顶点下标
 * @param visited 已到达过的顶点数组
 * @param queue 辅助数组
 * @return _Bool 是否找到目标顶点
 */

_Bool bfs(Graph graph, int startVertex, int targetVertex, int *visited, Queue queue) {
    offerQueue(queue, startVertex);
    visited[startVertex] = 1;
    while (!isEmpty(queue)) {
        int next = pollQueue(queue);
        printf("%c -> ", graph->vertex[next].data);
        GNode node = graph->vertex[next].next;
        while (node) {
            if (node->nextVertex == targetVertex) {
                printf("%c", graph->vertex[next].data);
                return 1;
            }
            if (!visited[node->nextVertex]) { // 如果没有走过，直接入队
                offerQueue(queue, node->nextVertex);
                visited[node->nextVertex] = 1; // 入队时设定为1
            }
            node = (GNode) node->next;
        }
    }
    return 0;
}
```



**图练习题**

1. 若一个图的边集为:$\{(A, B),(A, C),(B, D),(C, F)(D, E),(D, F)\}$，对该图进行深度优先搜索，得到的顶点序列可能是: B

   A: ABCFDE			B: ACFDEB			C: ABDCFE			D: ABDFEC

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5f1a580bc084a2f9ca465f9d38b3bd33.png)

> 因为这四个选项都是A开始的，所以说我们从A开始看，因为A连接了B和C，所以说A后面紧跟B或是C都可以，接着往下看，先看走B的情况，因为B只连接了一个D，所以说选项A直接排除，接着往下看，D链接了E和F，所以说选项C直接排除，此时只有选项D了,我们接着往后看，此时我们走F，紧接着的只有C,D也不满足，所以选择B（当然你怕不稳的话把B选项也推出来就行了）

2. 若一个图的边集为︰$\{(A, B),(A, C),(B, D),(C,F),(D,E),(D,F)\}$，对该图进行广度优先搜索，得到的顶点序列可能是: D

   A: ABCDEF		B: ABCFDE		C: ABDCEF		D: ACBFDE

3. 如下图所示的无向连通图，从顶点A开始对该图进行广度优先遍历，得到的顶点序列可能是: D

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/655cbb0a82ea7ce19655d8fafad903bb.png)



### 9.4 图的应用

#### 9.4.1 生成树和最小生成树

在开始讲解最小生成树之前，我们先来回顾一下之前讲解的连通分量。

- 对于无向图来说，如果图中任意两点都是连通的，那么我们就称这个图为**连通图**。
- 对于有向图来说，如果图中任意顶点A和B，既有从A到B的路径，也有B到A的路径，则称该有向图是**强连通图**。

而**连通分量**则要求是某个图的子图（子图可以是只包原图含部分顶点和边的图，也可以就是原图本身，因为定义只是子集，不是真子集)，并且子图也要是连通的才可以，还有一个重要条件是必须拥有极大顶点数（能够保证图连通的且包含原图最大的顶点数）并且包含所有依附于这些顶点的边（这个极大更偏向于顶点数的极大)，我们就称这个子图为**极大连通子图**

- 无向图的极大连通子图称为**连通分量**。
- 有向图的极大强连通子图称为**强连通分量**。

比如下面的有向图，这个图本身并不是连通的:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b4075bcc589eaeac9615dd748dbc76bb.png)

其中图1和图2都满足上述条件，都是强连通分量，本身就是连通并且已经到达最大的顶点数和边数了(只要再加入其他的顶点和边就会导致不连通）但是图3并不是子图（(A到B的边缺失）并且不是强连通的，所以说不是强连通分量。

又比如下面这个无向图，这个图本身也是不连通的:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0df617ccee9149ae220b027a065df1f2.png)

其中图1和图3都满足条件，都是连通分量，但是图2并没有到达最大的顶点数和边数，所以说不是连通分量。

当然上面都是原图不连通的情况，如果原图就是一个连通图，包含其所有顶点和边的子图就已经满足条件了，所以其本身就是一个连通分量;同样的，如果原图就是一个强连通图，那么其本身就是一个强连通分量。

总结如下:

- 如果原图本身不连通，那么其连通分量（强连通分量)不止一个。
- 如果原图本身连通，那么其连通分量（强连通分量)就是其本身。

极大连通子图我们回顾完了，那么我们接着来讨论一下**极小连通子图**。这里的极小主要是说的边数的极小，首先依然要是原图的子图并且是连通的，但是此时要求具有最大的顶点数和最小的边数，也就是说再去掉任意一条边会导致图不连通（直接理解为极大连通子图尽可能去掉能去掉的边就行了)

针对于极小连通子图，我们一般只讨论无向图(对于有向图，不存在极小强连通子图的说法，因为主要是讨论生成树）我们依然将原图就是连通图和原图不是连通图分开分析，首先是原图本身就是连通图的情况:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4363b1608c6ed2ee0d50d47a928bda1d.png)

原图本身就是连通图，那么其极大连通子图就是其本身，此时我们需要尽可能去掉那些"不必要"的边，依然能够保证其是连通的，也就是极小连通子图。可以看到右边两幅图，跟左边这幅图包含了同样的顶点数量，但是边数被去掉了一些，并且如果再继续去掉任意一条边的话，那么就会导致不连通，所以说左边两幅图都是右边这幅图的极小连通图（当然，就像上面这样，可能会出现多种方案，极小连通图不唯一）

我们发现，无论是去掉哪些边的情况，到最后一定是只留下N-1条边（其中N是顶点数）每个顶点有且仅有一条路径相连，也就是包含原图全部N个顶点的极小连通子图，我们一般称其为:**生成树**，为什么叫生成树呢，因为结点数和边数正好满足树的定义(且不存在回路的情况)，我们可以将其调整为一棵树:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d2661462e362f167efccc5b8bbca19df.png)

当然，这是原图本身就连通的情况，如果原图本身不连通的话，那么就会出现多个连通分量，此时就会得到一片**生成森林**，森林中的树的数量就是其连通分量的数量。

**程序生成有向图的生成树**

以下图为例

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2df58e1c8ddcb44fe057cc5cade98026.png)

我们如果按照深度优先遍历的方式，从G开始，那么就会得到下面的顺序:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fc858b35746350a38364ca02b82b42fd.png)

按照顺序我们就可以得到一棵生成树:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1583c957aaf9ff56573f7346df68f6c6.png)

虽然看着很奇怪，但是按照我们的顺序，得到的树就是这样的，可以发现，因为我们的深度优先搜索不会去走那些回头路，相当于直接把哪些导致回路和多余的边给去掉了，最后遍历得到的结果就是一颗生成树了。

同样的，我们来看看如果是按照广度优先遍历的方式，又会得到什么结果呢?

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/942be027a5b9928f7cb095ce55e73149.png)

最后得到的生成树为:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/24bbeb9d10ef4bd9d58dddd5ca828e0e.png)

实际上我们发现，在广度优先遍历下得到的生成树，也是按照每一层 在进行排列的，非常清晰。当然，因为深度优先遍历和广度优先遍历本身的顺序就不是唯一的，所以最后得到的生成树也不是唯一的。

**最小生成树**

生成树讨论完成之后，我们接着来讨论一下最小生成树，那么这个最小指的是什么最小呢?如果我们给一个无向图的边都加上权值(网图）现在要求生成树边的权值总和最小，我们就称这棵树为**最小生成树**（注意最小生成树不唯一，因为有可能出现多种方案都是最小的情况）比如下面的就是最后得到的最小生成树了∶

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c713e2deb08a836363720676127777bf.png)

构建最小生成树有两种算法，一种是**普利姆（Prim）**算法，还有一种是**克鲁斯卡尔（Kruskal）**算法
我们先来讨论第一种:

我们以下图为例:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9d0a09d196bc9c796168de76ac6550bd.png)

**普利姆算法**的核心就是从任意一个顶点开始，不断成长为一棵树，每次都会选择尽可能小的方向去进行延伸，比如我们一开始还是从顶点A开始:

此时与A相连的边有B和E，A的延伸方向有两个，此时我们只需要选择一个最小的就可以了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/262d7bf773eb191410004d9fca69a407.png)

此时我们已经构建出了由A、E组成的一棵树，同样的，我们需要去寻找与当前树中A、E顶点相连的所有顶点，包括B、G、H，哪一个最小，那么下一个延伸的就是哪一个，此时发现H和E之间最小，继续延伸:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/02407c6bd36b001ab41abd4dd0045f55.png)

现在已经变成了由A、E、H组成的一棵树，同样的，按照之前的思路继续寻找一个最小的方向进行延伸:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/46b0af3839ab001683d8091eeca08685.png)

继续进行延伸，发现F、K之间最小:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/12ce1f2d3f1569c733cee45f3c7d9062.png)

此时K、B和K、D和K、H的权重都是4，其中H顶点已经走过了，不能出现回路，所以说不考虑，此时随便选择K、B或是K、D都可以，不会影响后续结果:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5a16d8c70acb2e5c829b22ca7810dfe8.png)

此时依然是K、D为最小，所以说直接选择:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/26f6a7a89ac22eface44c0585ae9fe54.png)

紧接着，我们发现最小权重的来到了5，此时权重为5的边有B、E和H、I和B、D，但是由于E、D已经走过，此时直接选择H、I即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c4bc332181d347c71330ab50818b7e6f.png)

接着，我们发现I、G也是5，直接选择即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/76943b26fea65ea0223be8f2361e67ac.png)

然后最小权重此时就是6了，选择H、J和I、J都可以，随便选择一个即可:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/336f533d013751590b299bbea79a3baa.png)

此时，整个图的所有顶点就遍历完成了，现在我们去掉那些没用被采用的边，得到的结果就是我们的最小生成树了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5b3680bf0941460d64812fb50507ed30.png)

虽然样子有点丑，但是把它捋一捋就好了。可以看到省去的边都是尽可能大的边，或是那种导致回路的边，留下的边基本都是权重小的边，得到的就是最小生成树了（注意考试的时候只要按照我们的思路推是肯定没问题的，但是千万要仔细看，不要把边给看漏了，不然会出大问题）

**克鲁斯卡尔算法**，它的核心思想就是我们主动去选择那些小的边，而不是像上面一样被动地扩展延伸。

在一开始的时候，直接去掉所有的边，我们从这些边中一个一个选择出来（注意是任意一条边都可以选择，并不是只有选择的顶点旁边才能选择，这个过程中可能会出现多棵树，但是最后一定会连成一棵树的），最后形成一颗最小生成树，假设一开始什么都没选择，被选中的边我们一会用橙色标注:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/387eeaf2b123782a33b9ef668e6dd5af.png)

首先我们直接找到最小边，K、F，它的权值为2，所以说直接选择就行;

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ba1cfa1ae53503c04eaf3b444dc22efd.png)

紧接着就是F、H的边，权重为3，目前最小的了:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d24241ef191314dce8cd403eea731dd8.png)

此时最小的权重就只有4了，目前有4条边都可以进行选择，但是K、H这条边因为K和H都已经在树中了，所以说不能考虑，其他三条边都是没问题的，我们随便选择一条就行了：

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9ecc5e228d054baaaf211c80d7a50a05.png)

继续选择权重为4的边:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0beae3daa5115bdc04446cbc7ceee773.png)

此时权重就来到了5，那么权重为5的顶点我们也可以随便选择一条，只要不会导致出现回路就行了

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/d737e33e8cfa7220f01c3ca3ac09ab80.png)

此时连接G、I，我们发现出现了两棵树，没关系的，最后会连成一棵树的，我们继续选择其他权重为5的边:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/1a6a30a8656d46c591425c6968a4aa09.png)

此时我们选择A、E这条边，然后是H、l这条边，虽然这条边上的H和顶点都已经在树中了，但是它们并不属于同一棵树，这种情况也是可以连接的，然后我们继续选择权重为6的顶点:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/86df97c521f1e26f8f836d7255dd9cc2.png)

此时选择l、J或是H、J都可以（最小生成树不唯一）现在我们已经连接上所有的顶点了，最小生成树构建完成，我们把那些没有选择都边都扔了∶

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2be704d549632e6fd97c3a0bd8079a40.png)

#### 9.4.2 最短路径问题

我们首先从最简单的**单源最短路径**进行讨论，所谓单源最短路径，就是一个顶点出发，到其他顶点的最短路径，比如下面的这张图:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a2972bd5339777e87bf9e3f4e5d028d5.png)

要解决这种问题，我们可以采用**迪杰斯特拉(Djkstra)**算法，下面我们来看看迪杰斯特拉算法是如何让计算机来计算最短路径的，它跟普利姆算法求最小生成树有着很多相似之处，我们就从A出发，这里我们需要一个表来记录:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a6043df465f74b537bfde001014a1308.png)

dist这一行记录A到其他顶点的最短路径，path这一行记录的是最短路径所邻接的顶点，我们首先还是从A开始，与A直接相邻的两个分别是B和D，其中B的距离是2，D的距离是5，那么我们就先进行一下记录:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/cf041111db182b5326abdab564b0fca9.png)

因为都是从A过来的，所以说直接记录为A即可，接着我们继续找到当前A路径最短的一个顶点B，此时顶点B可以到达C、D、A,因为不能走回头路，不考虑A，那么目前从A到达C的最短距离就是经过B到达的，相当于A->B加上B->C的距离:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8e5389a6db044615f886ffd9897e9ea5.png)

然后我们来看顶点D，此时我们发现，除了A直接到D之外，从B也可以到达D，那么我们就可以比较一下，看是从B到D更短一些，还是从A直接到D更短一些$min(2+2,5)$，通过比较，我们发现从B绕过去会更短一些，只需要4即可，所以说我们将其更新一下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e2fec9f8db739ee31a7426bf818541de.png)

接着我们继续找到下一个离A最近的顶点D，D与顶点E和J相连，直接更新即可，比如E的最短路径就是相当于是A到D的最短路径加上D到E的路径，D到J也是同理:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/225b9be45a3dfef1e1cafbefa91d3a4f.png)

此时继续找到表中下一个距离A最近的顶点J，J可以到达H或者是E，按照同样的方式，我们看看是从D直接到E更短，还是从J到E更短，进行比较$min(6+3,8)$，得到结果是D直接过去更短，所以说不需要更新。然后H更新为J过去的最短路径:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/746468c8c2747b01b62692e8c7390c94.png)

我们接着来看下一个距离A最近的顶点C，此时C可以到达F和E，我们先来看E，还是对其进行比较，如果从C到达E更短，那么就更新为新的值, $min(7+4,8)$，最后仍然是从D到E最短，所以说不变，接着我们把F的值更新一下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0a1c07a6a9d0118998d851fd51d8a367.png)

然后我们来看下一个距离A最近的顶点E，E连接的就比较多了，此时E最短路径是从D过来的，那么我们就不考虑D，我们来依次看看与其相连的C、F、G、H、J(注意这里比较的是从E到这些顶点，之前比较的是从这些顶点到E，不要以为是一样的了)

- 从E到达顶点C: $min(8+4,7)$，故C继续采用原方案。
- 从E到达顶点F: $min(8+2,15)$，此时从E到达F路径更短，更新F。
- 从E到达顶点G:直接更新。
- 从E到达顶点H: $min(8+6,13)$，故H继续采用原方案。
- 从E到达顶点: $min(8 + 3,6)$，故J继续采用原方案。

最后得到:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6e2ec94cbb6cf1ebaa5e5d497e85b1de.png)

我们继续来到下一个离A最近的顶点F，F连接了G和E，但是由于当前最短路径是从E过来的，不能走回头路，所以说直接去看G，比较$min(10+5,17)$，得到从F到达G会更短，所以说更新G:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/49e9e8628f74bed3de63bd78a5f8bb3c.png)

然后我们接着看到下一个最短的顶点H，此时H与G和l相连，我们先来看G, $min(13+ 3,15)$，维持原方案。然后是l，直接更新即可;

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b68bf7e3f9070a6cfa60b2fb0bd78daf.png)

虽然此时表已经填完了，但是我们还没有把所有的顶点都遍历完，有可能还会存在更短的路径，所以说别着急，我们还得继续看。此时继续选择下一个离A最近的顶点G，它与E、F、H、I相连，由于其实从F过来的，排除掉F，我们来看看其他三个:

- 从G到达顶点E: $min(15+9,8)$，显然选择原方案就行。
- 从G到达顶点H: $min(15+3, 13)$，依然是选择原方案更短。
- 从G到达顶点l: $min(15+4,21)$，从G到达l更短，更新。

最后得到: 

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f402e31a8a7a1c23f71afbfa5355b3cd.png)

此时我们来看最后一个顶点I，与其连接的有G和H，因为是从G过来的，直接比较H就行了$min(19+8,13)$，维持原方案就行，至此，迪杰斯特拉算法结束。最后得到的表，就是最终的A到达各个顶点的最短路径值了，并且根据path这一栏的数据，我们就可以直接推出―条路径出来。

当然，这只是解决了**单源最短路径**问题，现在我们将问题的难度提升一下，比如我们现在想要求得图中每一对顶点之间的最短路径，那么该如何进行计算呢?最简单的办法就是，我们可以将所有的顶点都执行一次迪杰斯特拉算法，这样我们就可以求到所有顶点之间的最短距离了。只不过这种方式并不是最好的选择，对于这种问题，我们可以选择**弗洛伊德(Floyd)**算法。

比如下面的有向网图

 ![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/878321fc39aeec6da7329f6ef39a5674.png)

邻接矩阵

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/dcbadfdd6632ce878e44c39ce4b6811e.png)

而弗洛伊德算法则是根据最初的邻接矩阵进行推导得出的。规则如下:

- 从1开始，一直到n (n就是顶点数)的一个矩阵序列$A_1、A_2、.….A_n$，我们需要从最初的邻接矩阵开始，从A1开始不断往后推。
- 每一轮，我们都会去更新那些非对角线（对角线都是0，更新了还是0，所以说没必要看)、i行i列以外的元素，判断水平和垂直方向投影的两个元素之和是否比原值小，如果是，那就更新为新的值。迭代公式为:$A_t(i,j) = min(A_{t-1}(i,j),A_{k-1}(i,k)+A_{k-1}(k,j))$
- 经历n轮后，最后得到的就是最终的最短距离了。

我们从第一轮开始，第一轮是基于原有的邻接矩阵来进行处理的:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/8770651831f35a553c32e68c72daab59.png)

此时我们看到，除了对角线以外，就是B->C和C->B的这两个位置，我们按照上面的规则，进行计算

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/568abb8a2d63931a6b1d4c69371ac679.png)

同样的，我们继续看到C->B这个为止，按照同样的方式进行更新:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2c27e27a219967c4b311fdafe0b39c1d.png)

最后更新完成得到的结果如下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/bf6f723fbd03afac4dc335851579bd1b.png)

实际上我们发现，我们计算的和相当于是绕路的结果与当前直接走的结果相比较得到的。按照的同样的方式，我们开始第二轮:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/fceb11441131b2a2575bcca2341a78f0.png)

更新完成之后，C->A的距离变成了5:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ca629caf8212dab27b623d52d61088e2.png)

我们接着来看最后一轮:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/08c7ce5d679e97da2fff4bab9fd40555.png)

此时我们将A->B的距离也更新一下:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9398d4fbbd801fd668a03a107897cf26.png)

最后我们得到的矩阵，存放的就是所有顶点之间的最短距离了，当然这里我们只计算了最短距离，没有去记录从哪个方向到达此顶点的，各位小伙伴也可以在计算的同时单独在另一个表中记录一下从哪个顶点过去计算出来的最小距离，这里就不演示了。实际上这个算法对我们来说是更好理解的一种算法，并且在编写程序时也会很简单，我们以下图为例:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/87f6185682c82e13662c1d24c338094e.png)

```c++
#include <cstdio>

#define N 4
#define INF 1000

int min(int a, int b) {
    return a < b ? a : b;
}

void floyd(int matrix[N][N], int n) {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);
            }
        }
    }
}

int main() {
    int matrix[N][N] = {
            {0,   1, INF, INF},
            {4,   0, INF, 5},
            {INF, 2, 0,   INF},
            {3, INF, 7,   0}
    };
    for (int i = 0; i < N; i++) {
        printf("%4d %4d %4d %4d\n", matrix[i][0], matrix[i][1], matrix[i][2], matrix[i][3]);
    }
    printf("\n");
    floyd(matrix, N);
    for (int i = 0; i < N; i++) {
        printf("%4d %4d %4d %4d\n", matrix[i][0], matrix[i][1], matrix[i][2], matrix[i][3]);
    }
}
```

输出结果

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/09413d5fe2b5253b958f018244211457.png)



#### 9.4.3 拓扑排序

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/2dedf5084dc737e830c5da48a980e133.png)

这种图我们也称为**有向无环图（DAG)**，其实按照我们通俗的话来说，它就是个流程图罢了，我们只需要按照这个流程图来进行即可。像这种顶点表示活动或任务的图也称为**AOV图**。

**拓扑排序（Topological Order）**是指，将一个有向无环图(Directed Acyclic Graph）进行排序进而得到一个有序的线性序列。

比如上图的拓扑排序可以是以下的几种:

- A,B,C,D,E,F,G,H,l,J
- A,C,D,B,E,F,G,H,I,J
- A,D,C,B,E,F,G,H,I,J
- A,B,D,C,E,F,G,H,I,J

只要我们保证前置任务在后续任务之前完成即可，前置任务的完成顺序不做要求，所以拓扑排序不唯一。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c98c19d01883956c2da79668e4ebd2eb.png)

那么我们在程序中如何对一个有向无环图进行拓扑排序呢?以上图为例，其实很简单，我们还是利用队列来完成，我们每次只需要将那些入度为0的顶点，丢进队列中（注意丢进去之后记得更新一下图中其他顶点的入度)首先从A:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6c462c50a49e16aafa9747e819560d28.png)

此时队列中有A这个顶点，接着我们来看看图中剩余的顶点，哪些又是入度为0的顶点，可以看到D也是:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6cbb5fc36f958b51d71b21d6d57416b6.png)

当目前所有度数为O的顶点进入队列之后，我们开始出队，正式开始拓扑排序，在出队时直接打印，并且查看，当此顶点离开图之后，图中会不会有其他顶点的入度变为O，如果有，将其他顶点入队。比如此时A出队之后，那么A要从图中移除，现在B也变成了入度为O的顶点，所以说将B丢进队列:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/88b7645368d3f70230fdb017aa24268c.png)

接着，我们继续让D出队，我们发现D出队之后，E变成了入度为0的顶点，所以说将E入队:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/287e4512bebd82284516e52cc80ff6d2.png)

接着我们继续出队，B出队之后，我们发现没有任何顶点入度变为0了，所以说不管，继续:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/740fa675c089647ff52813f8e3494ea8.png)

继续将E出队，在E出队之后，顶点F、C都变成了入度为0的顶点，统统入队:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c4ea6544e85691605f5091eed4c99e52.png)

此时继续将C出队，我们发现没有任何顶点入队变为0，我们继续来看F:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4287c0ce96cb18a54c51194de53165ad.png)

当F出队后，顶点G变成了入度为0的顶点，此时将G入队:

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/318e66ac667d8916ed9bef78f87956c1.png)

剩下就是把G出队,然后F入队F再出队了∶

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/ab4093ff85230e3a38214b1ace6b439e.png)

