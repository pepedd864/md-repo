## 1. C#入门

### 1.1 简介

C#是一个现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的，由Ecma和ISO核准认可的。
C#是由Anders Hejlsberg和他的团队在.Net 框架开发期间开发的。
C#是专为公共语言基础结构（CLI）设计的。CLI由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。

### 1.2 特点

C#的特点:

1. 面向对象。
2. 面向组件。
3. 它产生高效率的程序。
4. 它可以在多种计算机平台上编译。
5. .Net框架的一部分。

### 1.3 强大的编程功能

c#强大的编程功能

虽然C#的构想十分接近于传统高级语言C和C++，是一门面向对象的编程语言，但是它与Java非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。

下面列出C#一些重要的功能:

- 布尔条件(Boolean Conditions)
- 自动垃圾回收(Automatic Garbage Collection)
- 标准库( Standard Library)
- 组件版本(Assembly Versioning)
- 属性(Properties)和事件(Events)
- 委托(Delegates)和事件管理(Events Management)
- 易于使用的泛型(Generics)
- 索引器(lndexers)
- 条件编译(Conditional Compilation)



## 2. 基础部分略

## 3. 委托

### 3.1 什么是委托

**委托**，可以理解为是C中**函数指针**的升级版

> 指针函数

```c
typedef int(* Calc)(int a, int b);
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/cd61446b6c8317fddd7610d116e68cc5.png)

**直接调用**和**间接调用**的本质：

- 直接调用：通过**函数名**调用函数。CPU通过函数名直接获得函数所在地址，执行=>返回
- 间接调用：通过**函数指针**调用函数。CPU通过读取函数指针存储的值，获得函数所在地址，执行=>返回

 无论是直接or间接，CPU最终执行的机器语言指令是一样的，最终效果也是一样的。

> 程序中一个重要的概念：一切皆地址。**程序的本质=数据+算法**。
>
> 变量是用来寻找数据的地址，函数是用来寻找算法的地址。
>
> - 变量(数据)是以某个地址为起点的一段内存中所存储的值
> - 函数(算法)是以某个地址为起点的一段内存中所存储的一组机器语言指令



### 3.2 委托的简单使用

不同于C中函数指针要先声明再使用，C#类库中已定义了许多常用的委托类型可以直接使用。常用的委托有：Action委托、Func委托

- Action委托：无参、返回值Void
- Func委托：泛型委托

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f7b169e7fa0675d9632e910e2cd3cfdb.png)



### 3.3 自定义委托

**委托是一种类**，而类是一种（引用）数据类型，所以委托也是一种数据类型。

它的声明方式与一般的类不同（不用Class XXX），而仿照函数指针的声明格式——一是为了照顾可读性，二是为了同C/C++的传统保持一致。

 

自定义委托的声明和使用：

![image-20231115222735331](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/33ba73821406db9375d71052a8a9a480.png)

**需要注意的点**

1. 注意声明委托的位置（要在命名空间中声明，和其他类同级。要避免错写在类里，导致变成嵌套类）
2. 委托与所封装的方法必须 “类型兼容” （返回值类型、参数列表个数&类型）

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e98bf4782aeb3e4555c98e3299551cfb.webp)

### 3.4 委托的一般使用

把委托当作参数传进方法。

即：通过委托，把方法A当作参数传给B方法。

**好处：** 假设方法B包含一个委托参数，委托封装了另一方法A。在B的方法体内，可以通过使用委托，动态调用方法A，从而形成一种**动态调用方法**的代码结构。

**这种方法常用的实践有以下两种：**

- 实践1：模板方法。借用指定的外部方法来产生结果。

相当于方法中有一个填空题，需要传进来的委托来进行补充。一般在代码中部使用委托间接调用方法，获取返回值，之后根据返回值来进行后续的运算。

- 实践2：回调（callback）方法。调用指定的外部方法。

把委托类型的参数传入主调方法，委托类型参数则封装了被回调的方法。由主调函数根据自己的逻辑来决定是否出发回调方法。

这类委托通常在函数末尾被使用，需要等主方法逻辑基本执行完后做出判断，委托封装的方法一般无返回值，常用来执行一些后续的工作，构成类似流水线的结构。

**模板方法的使用参考：**

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/04d459d2af7852581c3d5411d13c0fcb.png)

**使用模板方法的好处：**

后续Product类、Box类、WrapFactory类都不用再改动，只需要不断去扩展ProductFactory产品工厂类即可。

最大限度的实现了代码复用（Reuse），可以提高工作效率，同时降低Bug的引入。



**回调方法的使用参考：**

回调方法，也称做好莱坞方法（类似演员面试后给导演留下名片。演员无法联络导演，而导演如果选中某位演员就通过名片联络演员——这就是回调函数的一个经典场景）

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/5626ad6a66252aa66f4e53062bbb36c7.webp)

### 3.5 委托的缺点

使用委托要注意不能滥用。现实使用中一定要慎之又慎。

- 缺点1:这是一种方法级别的紧耦合，现实工作中要慎之又慎
- 缺点2:使可读性下降、debug的难度增加
- 缺点3:把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护
- 缺点4:委托使用不当有可能造成内存泄漏和程序性能下降

ps1.方法级别的紧耦合，往往是违反设计模式的

ps2.滥用委托为什么会造成内存泄露？

> 委托引用的方法，如果是实例方法，必定会隶属于一个对象。一旦委托引用了这个方法，方法对应的对象就必须存在于内存之中，即便没有其他引用变量引用该对象，该对象也不能释放——因为一旦释放，委托就不能再去间接调用对象的方法。所以有可能造成内存泄漏。随着泄露的内存越来越多。程序的性能会不断下降，直到程序崩溃。



### 3.6 委托的高级使用

几种常用的使用方式——

**A. 多播（multicast）委托**
 一个委托内部封装多个方法的方式，叫多播委托。
 一个委托内部封装一个方法的形式，叫单播委托。

![img](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a754b632cef47a354999dd5cf7870d0d.webp)

 

**B.隐式异步调用**

> 何为同步 / 异步？
>  同步：B等待A做完，再A的基础上接着做
>  异步：A和B各做各的，同步进行

**同步调用和异步调用的对比：**

每一个运行的程序是一个进程process。每个进程拥有一个多个线程thread。最先运行的是主线程，其他的是分支线程。

同步调用是指再**同一线程**内依次调用；

异步调用是指**在不同线程调用方法**，彼此在逻辑上互不影响（物理上有可能互相抢夺资源）。异步的底层原理是多线程。

> 串行==同步==单线程，并行==异步==多线程

![img](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e0534abf1ebf30d5ce753714cfcb7775.webp)

 

**使用委托进行隐式异步调用：**

多播委托中使用invoke()方法，是同步调用
 想要异步调用，需要使用委托提供的另一个方法：**beginInvoke()**

beginInvoke方法会自动生成一个分支线程，之后在分支线程中调用封装的方法
 两个参数：1、异步调用的回调；2、第二个参数一般也是null

![img](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7e56bc37137774d45b6c7a2a9750e0cf.webp)

**使用线程进行显式异步调用：**

![img](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/a8b7ad564c935b78759befc282caa2db.webp)

 在实际应用中，还有一点需要注意：应该适时地**使用接口Interface取代一些对委托的使用**。（比如java不具有委托的功能，完全用接口取代了委托）

 重构上面<模板方法>的代码，用接口取代委托：

![img](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/e2dea8ae89c663deab67d970fd825c25.webp)



## 4. 事件

### 4.1 事件的基本概念

事件的几个概念

1. **事件 Event**
2. **通知**
3. **事件参数**
4. **事件处理器**



#### 4.1.1 事件

事件，在日常语言中，可以理解为“能够发生的什么事情”。

而在 C# 中的定义是：一个隶属于类/对象、能够使类/对象具备**通知能力**的**成员**。

—— 作为类/对象的成员，事件、属性、方法等各自具备自己的功能，而<事件>的功能不在于事件本身，而是在于**在事件发生时通知订阅者**的能力。

——简而言之，**事件的功能就是通知**。



#### 4.1.2 通知

如何理解通知？

比如，我们说 手机具有响铃事件，就意味着——手机可以通过响铃这个事件来通知关注手机的人，也可以说，响铃这个事件让手机具备了通知关注者的能力。

当响铃事件发生时，从手机角度看——手机通知关注他的人，要求关注他的人采取行动；

从人的角度看——人得到手机的通知，可以采取行动了；



#### 4.1.3 事件参数

在通知的基础上更进一步，有时伴随着通知，可能会产生一些与事件相关的数据。

比如手机来电响铃or接收微信响铃，这时手机在提醒关注者的同时也会将消息（电话、微信）发送给关注者 —— 这种**经由事件发送出来的与事件本身相关的数据**，就是消息，被称为**事件参数 EventArgs**。



#### 4.1.4 事件处理器

手机的关注者被通知之后，会去检查事件参数，之后根据参数内容采取相应的行动，比如接电话、回微信、或者可能直接忽略消息给手机关机 —— 这种**根据通知和事件参数采取行动的行为**称为**响应事件**，关注者在响应事件时具体所作的事情叫做 **事件处理器 EventHandler**。



#### 4.1.5 事件的功能

由以上分析可以得出，**事件的功能 = 通知（其他的对象/类） + 可选的事件参数（即详细信息）**

因此，在程序中，事件用于**对象与类间的动作协调与信息传递（消息推送）**

—— 事件一旦发生，订阅该对象的对象们会依次接到通知，随后各自做出响应——这时各个对象协调统一的开始工作，程序开始运转。



### 4.2 事件的原理

事件模型（event model），又叫发生—>响应模型。

>- “发生>响应"中的5个部分一一闹钟响了你起床、孩子饿了你做饭.....这里隐含着”订阅”关系
>- 发生>响应”中的5个动作--(1)我有一个事件>(2)一个人或者一群人关心我的这个事件>(3)我的这个事件发生了>( 4)关心这个事件的人会被依次通知到>(5)被通知到的人根据拿到的事件信息(又称“事件数据”、“事件参数”、“通知”)对事件进行响应( 又称”处理事件）。



5个部分：闹钟响了我起床 —— 这里 闹钟、响铃、我、做饭共计4个部分，加上隐含的“订阅”关系，总计5个部分。

5个动作：第4个动作里，依次通知——通知的顺序就是订阅的顺序，先订阅先通知



### 4.3 一些说明

一些含义相同的说法

> 事件订阅者
>
> 事件消息的接收者
>
> 事件的响应者
>
> 事件的处理者
>
> 被事件所通知的对象



>事件消息
>
>事件信息
>
>事件数据
>
>事件参数



- 事件多用于桌面、手机等开发的客户端编程，因为这些程序经常是用户通过事件来”驱动”的
- 各种编程语言对这个机制的实现方法不尽相同
- Java语言里没有事件这种成品，也没有委托这种数据举型。Java的“事件”是使用接口来实现的
- MVC、MVP、MVVM等模式，是事件模式更高级、更有效的“玩法
- 日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少，所以先学使用



### 4.4 事件模式的5个组成部分

- 事件的拥有者（event source，对象）
- 事件成员（event，成员）
- 事件的响应者（event subscriber，对象）
- 事件处理器（event handler，成员）—— 本质上是一个回调方法
- 事件订阅 —— 把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的“约定”

**事件拥有者**：事件的**源头**，一定是对象/类。（又称为事件的源头、事件的主体、事件消息的发送者）

**事件**：本身是用来通知的工具，是**被动发生**的，需要事件拥有者在内部逻辑中触发。

**事件响应者**：订阅了事件的对象or类，它们在接收到通知后，会使用自身拥有的事件处理器来根据业务逻辑处理事件。

**事件处理器**：事件响应者的一个方法成员。本质上是一个回调方法。

**事件订阅**：解决了三个问题 ——

1. 事件发生时，拥有者通知哪些对象 
2. 拿什么样的事件处理器才能处理事件 

- 不同的事件（比如电话、微信）所要做出的响应是不同的。
- 当订阅者进行事件订阅时，C#编译器会进行严格的类型检查，用于订阅事件的事件处理器必须和事件遵守同一个约定
- “约定”既约束事件发送的消息类型，又约束事件处理器处理消息的类型。只有二者的消息类型匹配时才能够订阅。

> 以上所说的"约定"，本质上就是委托。因此常说事件是基于委托的。

3. 事件的响应者具体用什么方法来处理事件

- 订阅时会进行具体的指定



### 4.5 事件模型常见的几种组合方式

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/dddd3e9e642e96f5ae2e0d8402b1a701.webp)

1星：标准的事件机制模型，MVC/MVP等设计模式的雏形

2星：事件拥有者同时也是事件响应者，用自己的方法订阅自己的事件。常用的模型

3星：应用最广泛的。拥有者是响应者的一个字段成员（包含关系）

　　比如窗口对象包含按钮。按钮是窗口的成员。一旦点击按钮，窗口的某个订阅方法会得到通知，给窗口做出相应变化（比如页面跳转之类）

　　之所以应用广泛，是因为它是windows平台默认的事件订阅和处理结构——现在仍在使用。

**使用中需要注意的点：**

- 事件处理器是方法成员
- 挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名，这是个“语法糖“
- 事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测
- 事件可以同步调用也可以异步调用

### 4.6 简单实践

**实例1：**

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/beab23fc2d94f939f8cf565e4a22a341.png)



**实例2：**

- 反映1星的组合方式——拥有者和响应者是不同对象

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/0dd18a364c8588d1db114e7536358941.png)



**实例3：**

反映2星的组合方式——拥有者和响应者是同一个对象

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/c44e40bb6a0565926514faeb58d5e550.png)



**实例4：**

反映2星的组合方式——拥有者是响应者的一个字段成员，响应者用方法订阅着自己字段成员的事件

实现案例：窗口里一个文本框一个按钮，点击按钮，文本框显示HelloWorld。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/9be7889c277930e97e704f0a5325cc46.png)



**实例5：**

事件处理器是可以重用的（比如两个Button绑定同一个事件）
前提是：这个事件处理器必须和被处理的事件保持约束上的一致。

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/b5343d584b9901735474b7aaa0ca81f7.png)



**实例6：**

额外几种接挂处理器的方式

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/7c94ab998a6e76df704aaf7924c4442f.webp)