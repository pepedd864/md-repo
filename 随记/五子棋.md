# 五子棋

## 1. 如何存储信息

### 1.1 问题

做一个五子棋游戏，需要存储哪些信息？

1. 谁是黑棋？谁是白棋？
2. 现在游戏结束了吗？若游戏结束，谁赢了？若没结束，现在该谁下棋了？
3. 如果游戏支持悔棋，现在有人在请求悔棋吗？是谁在请求？
4. 如果游戏支持认输，重新审视是否满足第2点。
5. 当前场上棋子的分布

### 1.2 解决方案

#### 1.2.1 谁黑谁白

|                                                              | 优点                       | 缺点                                         | 适用范围                                           |
| ------------------------------------------------------------ | -------------------------- | -------------------------------------------- | -------------------------------------------------- |
| 方案一：用1个变量标识你是哪个玩家；再用1个变量标识哪个玩家是黑棋。 | 有玩家号码标识，可扩展性好 |                                              | 游戏其它功能需要跟玩家编号有关联时可用该方案。     |
| 方案二：用1个变量标识你是黑棋或白棋。                        | 只需要1位(bit)即可         | 因为玩家没有固定的玩家号码，所以可扩展性较差 | 不做扩展功能，只做最简洁的联机五子棋时可用该方案。 |

> 两个方案都是可以的，只是需要看实际场景。如果你只想做个简单的五子棋，用方案二就够了。如果考虑扩展性，推荐方案一。

#### 1.2.2 游戏结束了吗？谁赢了？该谁下棋了？

|                                                              | 优点                                                         | 缺点                           | 适用范围                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------ | -------------------------------------------------- |
| 方案一：用1个变量标识游戏状态。黑赢、黑输、该玩家1下棋、该玩家2下棋等都是一种状态。 | 少了运算过程，快了几十毫秒。游戏状态的可扩展性好，可以新增状态（例如认输、悔棋等） |                                | 游戏会有多种状态时可用该方案。                     |
| 方案二：只记录场上棋子的分布情况，通过计算是否有5连珠，判断谁输谁赢。 | 占用空间少                                                   | 若要支持认输，只能回到方案一。 | 不做认输功能，只做最简洁的联机五子棋时可用该方案。 |

> 两个方案都是可以的，只是需要看实际场景。如果你只想做个简单的五子棋，用方案二就够了。如果考虑扩展性，推荐方案一。

#### 1.2.3 悔棋

悔棋有2种形态：

1. 请求悔棋后，无需对方确认，直接悔棋。
2. 请求悔棋后，需要对方同意，才能悔棋成功。

第一种形态比较简单，悔棋后，直接更新游戏数据即可。

第二种形态，可以通过2.2的方案一来实现。游戏状态如下：

- 等黑下棋
- 等白下棋
- 黑胜利
- 白胜利
- 黑请求悔棋
- 白请求悔棋

#### 1.2.4 认输

认输和悔棋不同，认输是单方面提出认输，游戏即可结束，宣布另一方的胜利。

可以通过2.2的方案一来实现，游戏状态同2.3即可实现认输功能。

#### 1.2.5 状态机

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/dfecdfb2d85c5dffcfb929d92b29d94b.webp)

> 图中没把「认输」动作画出来，因为「认输」比较简单，从其它四个状态分别拉2个线，指向「黑胜利」和「白胜利」，表示「白认输」和「黑认输」即可。



#### 1.2.6 场上棋子的分布

> 注：五子棋棋盘通常是15X15的布局，也有AI对战中，使用更大的棋盘，例如20X20。这里我们以15X15的棋盘来分析。

|                                                              | 优点                                                         | 缺点                                                         | 适用范围                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 方案一：用一个列表存储已落的棋子，列表顺序表明棋子顺序，列表每一项的值代表棋子的位置，值为0-224（刚好225个值），奇数位置是黑棋，偶数位置是白棋。 | 针对棋子少的棋局，存储空间小于方案二；保存了位置信息，便于悔棋、复盘等。 | 每个棋子需要8bit存储，**空间利用率约225/256=88%**，并没有充分利用 | 大多数场景。                                                 |
| 方案二：使用长度为225的列表，值为0或1或2，分别表示该位置没棋、黑棋、白棋。 | 针对任意棋子分布，占用空间是固定的。若用3进制，只需225bit，转换为2进制，**只需要log_2(3^225)=357位** | 如果想记录顺序信息，需要额外空间。                           | 你用这个棋盘画画的时候，棋子往往很多，且不需要保留顺序信息，可用该方案。 |

场上小于357/8=45枚棋子时，方案一占空间更小，否则方案二空间更小。

**如果是联机《五子棋》游戏，推荐方案一，毕竟顺序信息还是很有用的。而存储空间大一点也是没关系的，影响可忽略不计。**

另外补充一句，棋子位置信息存储时可以直接用0-224，但是转义给人类时，建议直接转换为15进制，这样它的十位就可以是行信息，个位就可以是列信息。

- 例如224=`ee`，表明第e（15）行第e（15）列；
- 例如0=`00`，表明第0行第0列；
- 例如10=`0a`，表明第0行，第a（10）列。



## 2. 判断输赢

### 2.1 输入输出

**输入：**

用一个列表存储已落的棋子，列表顺序表明棋子顺序，列表每一项的值代表棋子的位置，值为0-224（刚好15*15=225个值），奇数位置是黑棋，偶数位置是白棋。

以这局为例：[五子棋 - game.hullqin.cn](https://game.hullqin.cn/wzq/?p=000110112021303140)

注意：网址参数中，是用15进制表示棋子的。每2位是一个棋子。

```js
// 网址参数对应这样的输入数据：
const input = [0, 1, 15, 16, 30, 31, 45, 46, 60];
// 分别是 00 01 10 11 20 21 30 31 40 奇数位置是黑棋，偶数位置是白棋
```

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/6117bc54bcdc7edb6ab11abb2527373f.webp)

**输出：**

有3种可能：

1. 黑棋赢
2. 白棋赢
3. 没人赢（游戏应该继续）



**基本假设**

有且仅有最后一手棋，导致某方五联珠胜利。

也就是说：

- 如果最后一手是黑棋，那么当前白棋一定没赢，只需要判断黑棋是否赢，就知道输出是1还是3。
- 如果最后一手是白棋，那么当前黑棋一定没赢，只需要判断白棋是否赢，就知道输出是2还是3。

这个基本假设，符合真实的五子棋场景。

### 2.2 解决方案

#### 2.2.1 五分钟方案

先找到最后一手棋的颜色，拿到该颜色棋子的集合：

```js
const input = [0, 1, 15, 16, 30, 31, 45, 46, 60];
const pieces = input.filter((piece, index) => input.length % 2 !== index % 2);
console.log(pieces);
```

比如`input.length`是奇数，表明最后一手是黑棋，筛选出`input`的所有第偶数项(从0开始）都是黑棋。

然后遍历这个集合，看看它上下左右斜共8个方向，有没有5连珠，若有，则他赢；否则他没赢。

```js
const input = [0, 1, 15, 16, 30, 31, 45, 46, 60];
const pieces = input.filter((piece, index) => input.length % 2 !== index % 2);
console.log(pieces);

const judge = (pieces) => {
  const pieceSet = new Set(pieces);
  for (let i = 0; i < pieces.length; i++) {
    const piece = pieces[i];
    if (piece % 15 >= 4 && pieceSet.has(piece - 1) && pieceSet.has(piece - 2) && pieceSet.has(piece - 3) && pieceSet.has(piece - 4)) return true;
    if (piece % 15 <= 10 && pieceSet.has(piece + 1) && pieceSet.has(piece + 2) && pieceSet.has(piece + 3) && pieceSet.has(piece + 4)) return true;
    if (Math.floor(piece / 15) >= 4 && pieceSet.has(piece - 15) && pieceSet.has(piece - 30) && pieceSet.has(piece - 45) && pieceSet.has(piece - 60)) return true;
    if (Math.floor(piece / 15) <= 10 && pieceSet.has(piece + 15) && pieceSet.has(piece + 30) && pieceSet.has(piece + 45) && pieceSet.has(piece + 60)) return true;
    if (piece % 15 >= 4 && Math.floor(piece / 15) >= 4 && pieceSet.has(piece - 1 - 15) && pieceSet.has(piece - 2 - 30) && pieceSet.has(piece - 3 - 45) && pieceSet.has(piece - 4 - 60)) return true;
    if (piece % 15 <= 10 && Math.floor(piece / 15) <= 10 && pieceSet.has(piece + 1 + 15) && pieceSet.has(piece + 2 + 30) && pieceSet.has(piece + 3 + 45) && pieceSet.has(piece + 4+ 60)) return true;
    if (piece % 15 >= 4 && Math.floor(piece / 15) <= 10 && pieceSet.has(piece - 1 + 15) && pieceSet.has(piece - 2 + 30) && pieceSet.has(piece - 3 + 45) && pieceSet.has(piece - 4 + 60)) return true;
    if (piece % 15 <= 10 && Math.floor(piece / 15) >= 4 && pieceSet.has(piece + 1 - 15) && pieceSet.has(piece + 2 - 30) && pieceSet.has(piece + 3 - 45) && pieceSet.has(piece + 4 - 60)) return true;
  }
  return false;
};

console.log(judge(pieces));
```

**算法描述**

> 如果最后一手为黑棋，则遍历所有黑棋：以该黑棋为五联珠的顶点，看看它的上、下、左、右、左上、右下、左下、右上是否有连续的4个黑棋，只要找到任意一项成立，则黑棋赢。若遍历了所有棋子的所有方向后，没找到能使任意`if`成立的，则表明黑棋没赢。
>
> 里面有1个`for`循环，用于遍历黑棋。8个`if`判断，分布判断8个方向是否有4连珠。

