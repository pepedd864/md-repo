# 随记

## 1.JWT和Session

**令牌方案**，一种验证用户信息的方案，这里有两种实现：

- Cookie-Session方式（引用令牌）：用户信息由服务器统一管理，令牌为一个随机字符串可以唯一指向详细的用户信息，这个指向关系当然也是由服务器保留
- JWT方式（自包含令牌）：用户信息经过处理直接作为令牌，相当于用户信息是保留在客户端的

**Cookie-Session方式**

- 优点
  - 可以非常方便的管理在线用户：因为用户相关的状态信息都是存储在服务器的，比如统计实时在线人数，强制某些违规用户下线等等
  - 相对于在网络和客户端机器传递用户信息，一个没有任何含义的随机字符串SessionId被泄露所造成的影响更小
- 缺点
  - 只能在 web 场景下使用，如果是 APP 的情况，不能使用 cookie 的情况下就不能用了；
  - 如果是分布式服务，需要考虑 Session 同步问题
  - 有状态

**JWT方式**

- 优点

  - 并不特定依赖于Cookie方式存储

  - 用户信息包含在客户机，分布式服务中多台机器都可以认识，认证它
  - 无状态

- 缺点
  - 令牌分发之后，不受服务器控制，不能主动让客户端下线
  - JWT长度较长，每次请求都携带浪费网络流量（对于网络服务器来讲，流量一般很贵）
  - 解析JWT需要花费比Session更多的算力，是一笔不小的开销
  - 续签问题，JWT颁发之后就无法更改，所以在前端需要使用在每次请求都获取一个Token或者双Token（一个长期Token用来刷新授权Token，一个短Token作为授权Token）。

综合来看，对于单点登录和会话管理来说，jwt并不适合



## 2. MyBatisPlus对于逻辑删除和唯一索引的兼容问题

### 2.1 逻辑删除

逻辑删除就是给数据表添加一个固定字段，用该字段的值来表示这条数据当前是否被删除，并把 delete 操作修改为 update 操作。

比如，在我的项目中某些表会有一个固定的 `deleted` 字段，该字段是 `tinyint` 型的，其取值只有 0 和 1 两种，0表示这条数据未删除，1表示已删除，默认值为 0。

当我要删除某条数据时，我会将这条数据的 `deleted` 值置为 1，而不会使用 delete 去真正的把它删掉。同时，我的所有 insert 语句和 update 语句都会带上一个固定的条件 `deleted = 0` ，来过滤掉所有在逻辑上被删除的数据。

> 阿里巴巴Java编码规约提出：POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。
>
> 我原来是用的 `is_deleted`，现已全部更改为了 `deleted`。

同样的，也来讲讲这样做的好处：

- 方便数据恢复，保护数据本身的价值。
- 保证数据连续性，对主键的影响可能会导致底层B+树重建，而 delete 和 update id 都会影响主键。

事实上，在大多数公司里，都会采用逻辑删除的方式，因为数据的价值更大，被删除的数据也非常有记录价值，这样的操作也并不会提高太多的操作难度。



### 2.2 MyBatisPlus使用逻辑删除

1. 在MySQL中给那些要改为逻辑删除的表添加一个 `deleted` 字段，当然也可以叫 `flag` 或者是别的名字，只要你喜欢就好。类型 `tinyint` 就够了，默认值最好也设置一下。
2. 在你的Java代码中给刚刚修改过的表的实体类添加对应的属性：

```java
public class User {
	// 添加deleted字段
    Integer deleted;
}
```

3. 在项目的配置文件（application.yml）当中添加对应的配置：

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

4. 如果你的Mybatis-Plus版本在 3.3.0 以下，那你还需要在实体类的字段上添加 `@TableLogic` 注解：

```java
@TableLogic
Integer deleted;
```



### 2.3 逻辑删除与唯一索引的冲突

对于MySQL而言，逻辑删除会导致唯一索引（UNIQUE KEY）的异常。

- 原因很简单，已经删除的数据仍然存在，当再次插入一条同样的数据时，就会抛出异常。

- 比如在我的 user 表中 username 字段设置了 UNIQUE KEY ，我先插入一条`username = 阿杆`的数据，再把这条数据逻辑删除掉，然后再重新插入一条`username = 阿杆`的数据。

  那么理论上来说此时是应该允许插入的，但由于我使用了逻辑删除，MySQL不允许存在两条数据出现同样的 `username = 阿杆`的场景，此时就出现了异常。

- 当然，逻辑删除与唯一索引的冲突是可以解决的，解决方案也不难。

我们可以在原来的唯一索引里加上`deleted`字段，同时再删除数据的时候把`deleted`修改为表id，这样就可以保证未删除的数据不会出现重复值了，而且不会受到已删除数据的影响。但你要记得重写SQL方法，不然Mybatis-Plus还是会帮你修改为配置文件里的那个默认值。

```sql
UNIQUE KEY `username` (`username`,`deleted`) USING BTREE
```



## 3. 移动端点击的默认阴影效果

使用这句css即可

```css
-webkit-tap-highlight-color: transparent;
```



## 4. 文本换行

### 4.1 单行

语法

```css
overflow:hidden;
text-overflow:ellipsis;
white-space:nowrap
```

### 4.2 多行

**直接用css属性设置(只有-webkit内核才有作用)**

语法

```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;
```

移动端浏览器绝大部分是WebKit内核的，所以该方法适用于移动端；

- -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。
- display: -webkit-box 将对象作为弹性伸缩盒子模型显示 。
- -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。
- text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。



## 5. vite nginx 配置 gzip模式

> 缩小打包体积

1. 首先安装插件`npm install vite-plugin-compression -D`

2. 参数

   - `filter`：过滤器，对哪些类型的文件进行压缩，默认为`/.(js|mjs|json|css|html)$/i`

   - `verbose`: true：是否在控制台输出压缩结果，默认为 `true`
   - `threshold` ：启用压缩的文件大小限制，单位是字节，默认为 `0`
   - `disable` : false：是否禁用压缩，默认为 `false`
   - `deleteOriginFile` ：压缩后是否删除原文件，默认为 `false`
   - `algorithm` ：采用的压缩算法，默认是 `gzip`
   - `ext` ：生成的压缩包后缀

```js
viteCompression({
    verbose: true,    
    disable: false,
    threshold: 10240,  
    algorithm: 'gzip',
    ext: '.gz',
})
```

压缩效果明显

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/24a46714e4408b53b48a948c76727a89.png)

然后配置Nginx

```
server{
    #gzip
    #开启gzip功能
    gzip on; 
    #开启gzip静态压缩功能
    gzip_static on; 
    #gzip缓存大小
    gzip_buffers 4 16k;
    #gzip http版本
    gzip_http_version 1.1;
    #gzip 压缩级别 1-10 
    gzip_comp_level 5;
    #gzip 压缩类型
    gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; 
    gzip_vary on; 
}
```

压缩前

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/4cb722d92caaec92b0c58ca680076d5c.png)

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/807f699dfedb74d713d142b16f69808a.png)



**效果明显**



## 6. vite配置postcss 浏览器兼容

**什么是postcss**

postcss官网：[www.postcss.com.cn/](https://link.juejin.cn?target=https%3A%2F%2Fwww.postcss.com.cn%2F)

postcss是一个用 JavaScript 工具和插件转换 CSS 代码的工具，postcss自身没有什么功能，只是一个平台，可以下载各种插件，从而实现一些功能！

- [**Autoprefixer**](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer) 自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。
- [**PostCSS Preset Env**](https://link.juejin.cn?target=https%3A%2F%2Fpreset-env.cssdb.org%2F) 帮你将最新的 CSS 语法转换成大多数浏览器都能理解的语法，
- [CSS 模块](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcss-modules%2Fcss-modules) 能让你你永远不用担心命名太大众化而造成冲突，只要用最有意义的名字就行了。

注：[PostCSS Preset Env](https://link.juejin.cn?target=https%3A%2F%2Fpreset-env.cssdb.org%2F) 实际预设了很多好用的css插件，完全可以替代autoprefixer使用。



首先安装

```bash
pnpm install postcss-preset-env -D
```

在vite.config.js中打开配置

```js
css: {
  postcss: {
    plugins:[postcssPresetEnv()]
  }
},
```

**开启前**

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/f49e05f9734eaaa917dd8a17b6f1bc33.png)

**开启后**

![](https://picgo-img-repo.oss-cn-beijing.aliyuncs.com/img/be4806b0aa9b8030a285813c6c0cdcf1.png)



## 7. BEM命名规范

随着项目更新迭代变得庞大，如果没有一个高效的CSS命名规范，我们维护时将会变得十分困难，CSS命名的重要性不容忽视，因为它直接影响到代码的可维护性、可读性和协作能力。

- **BEM是什么？**

BEM（Block Element Modifier）是一种用于命名和组织CSS类的命名约定，它有助于更有效地管理和维护大型代码库中的CSS样式。

BEM中的类名通常是非常具体的，因此它们减少了不同样式之间的冲突可能性。这有助于确保不同组件或模块之间的样式不会意外地相互影响。BEM鼓励将样式封装到块和元素中，这有助于创建可重用的CSS组件。这些组件可以在不同的项目和页面中使用，提高了代码的可重用性和一致性。

BEM是一种有助于更有效地管理和维护CSS代码的命名约定，适用于各种项目，特别是在大型项目、设计系统和团队协作方面发挥作用。它有助于提高代码的质量、可维护性和可读性。



### 7.1 BEM命名

BEM（Block Element Modifier）是一种用于给HTML和CSS命名的规则，目的是让你的网页代码更容易理解和维护。它的原则很简单：

好的，让我们以"WeUI"中的一个示例来解释BEM命名规范。

假设我们有一个WeUI中的按钮组件，我们可以使用BEM规范为它命名：

1. **块（Block）** ：按钮组件是一个独立的块，我们可以将其称为 `.weui-button`。
2. **元素（Element）** ：按钮组件内部可能有不同的元素，例如按钮的文本或图标。我们可以用元素来表示这些内部组件，例如 `.weui-button__text` 表示按钮内的文本元素。
3. **修饰符（Modifier）** ：修饰符用于改变块或元素的外观或状态。例如，如果我们想要创建一个大号按钮，我们可以使用修饰符，比如 `.weui-button--large`。

```html
<button class="weui-button weui-button--large">
    <span class="weui-button__text">点击我</span>
</button>
```

在这个例子中，`.weui-button`是块，`.weui-button__text`是按钮内的元素，`.weui-button--large`是按钮的修饰符。

概括一下

1. **库名（Library Name）** ：库名是您的CSS类名的前缀，通常代表整个库或项目的名称。它用于避免与其他库或项目中的类名冲突,这里的库名是weui
2. **组件名（Component Name）** ：组件名是特定组件的名称，它描述了这个组件的用途。组件名通常是块（Block）的一部分，这里的button就是一个组件按钮
3. **状态名（State Name）** ：状态名用于表示组件的不同状态或变体。它通常是修饰符（Modifier）的一部分，这里--large表示状态名
4. **元素名 (Element Name)** 是指组件内部的小部分，通常是与块（Block）相关的元素,例如__text

### 7.2 为什么要使用BEM

1. **清晰可读的类名结构：** BEM使用块、元素和修饰符的结构，使类名变得非常清晰和直观。通过查看类名，您可以轻松地理解它们与页面中的HTML元素的关联，提高了代码的可读性。
2. **避免样式冲突：** BEM的类名通常是非常具体的，减少了不同样式之间的冲突可能性。这有助于确保不同组件或模块之间的样式不会意外地相互影响。
3. **可重用性：** BEM有助于创建可重用的样式组件，这些组件可以在不同的项目和页面中使用。这节省了时间和努力，因为您不必在每个新项目中重新创建相同的样式。
4. **提高协作：** BEM提供了一种一致的命名约定，有助于团队成员更轻松地协作。所有人都可以遵循相同的规则，减少混乱和不一致性。



